<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Invader Stable v5 (Responsive U + WallDrop)</title>
<style>
  html,body{margin:0;padding:0;background:#000;overflow:hidden;touch-action:none;}
  #bg{position:fixed;inset:0;}
  #hud{
    position:fixed;top:8px;left:8px;z-index:10;color:#fff;
    font:14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    user-select:none;
  }
  #msg{
    position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
    color:#fff;font:700 40px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    text-shadow:0 2px 0 rgba(0,0,0,.5);
    z-index:20;pointer-events:none;text-align:center;
  }
  .px{
    position:absolute;
    width:calc(var(--u) * 1px);
    height:calc(var(--u) * 1px);
  }
  #player{position:absolute;left:50%;bottom:70px;transform:translateX(-50%);z-index:8;}
  .enemy{position:absolute;z-index:7;}
  .shield{position:absolute;z-index:6;}

  .b{position:absolute;width:4px;height:10px;background:cyan;z-index:9;}
  .eb{position:absolute;width:4px;height:10px;background:orange;z-index:9;}

  .boom{position:absolute;width:4px;height:4px;background:orange;pointer-events:none;z-index:30;}

  #ctrl{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    display:flex;gap:12px;z-index:50;
  }
  .btn{
    width:64px;height:64px;border-radius:50%;
    background:rgba(0,0,0,.55);
    border:2px solid #0ff;color:#fff;
    font-size:22px;font-weight:800;
    user-select:none;
  }
</style>
</head>

<body style="--u:6">
<canvas id="bg"></canvas>

<div id="hud">
  SCORE <span id="score">0</span> /
  WAVE <span id="wave">1</span><br>
  LIFE <span id="life">❤️❤️❤️</span>
</div>
<div id="msg"></div>

<div id="player"></div>

<div id="ctrl">
  <button class="btn" data-k="L">◀</button>
  <button class="btn" data-k="R">▶</button>
  <button class="btn" data-k="S">A</button>
</div>

<script>
/* ========= デバイス別ドットサイズ ========= */
function calcU(){
  if (innerWidth >= 1200) return 7; // 大画面PC
  if (innerWidth >= 800)  return 6; // ノート/タブレット
  return 4;                         // スマホ（小さめ）
}

let U = calcU();
document.body.style.setProperty("--u", U);

let isMobile = innerWidth < 800;

/* ★モバイルは横8・縦3、PCは横12・縦4 */
function getCols(){ return isMobile ? 8 : 12; }
function getRows(){ return isMobile ? 3 : 4; }

/* ========= Canvas 背景 ========= */
const bg = document.getElementById("bg");
const ctx = bg.getContext("2d");
function resizeCanvas(){ bg.width = innerWidth; bg.height = innerHeight; }
resizeCanvas();

const stars = [...Array(120)].map(()=>({x:Math.random()*innerWidth,y:Math.random()*innerHeight,s:0.6+Math.random()*1.2}));

/* ========= HUD ========= */
const scoreEl = document.getElementById("score");
const waveEl  = document.getElementById("wave");
const lifeEl  = document.getElementById("life");
const msgEl   = document.getElementById("msg");

/* ========= ゲーム状態 ========= */
let score = 0;
let wave  = 1;
let life  = 3;

let ready = true;
let clearing = false;
let over = false;

let invincible = 0;
let safeTimer  = 0;
let canShoot   = true;

let holdL = false, holdR = false;

/* ========= ユーティリティ ========= */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function hit(ax,ay,aw,ah,bx,by,bw,bh){
  return !(ax+aw<bx || ax>bx+bw || ay+ah<by || ay>by+bh);
}

/* ========= 色 ========= */
function shieldColor(){
  if (wave < 3) return "#66ffaa";
  if (wave < 5) return "#66ccff";
  if (wave < 8) return "#ffcc66";
  return "#ff6666";
}
function playerColor(){
  const sc = shieldColor();
  if(sc==="#66ffaa") return "#44ffdd";
  if(sc==="#66ccff") return "#66ff66";
  if(sc==="#ffcc66") return "#66aaff";
  if(sc==="#ff6666") return "#66ffcc";
  return "#44ff88";
}
function updateLifeHud(){
  lifeEl.textContent = "❤️".repeat(Math.max(0, life));
}

/* ========= スプライト描画 ========= */
function drawSprite(parent, spriteLines, color){
  parent.innerHTML = "";
  for(let y=0;y<spriteLines.length;y++){
    const row = spriteLines[y];
    for(let x=0;x<row.length;x++){
      if(row[x]==="1"){
        const p = document.createElement("div");
        p.className = "px";
        p.style.left = (x*U) + "px";
        p.style.top  = (y*U) + "px";
        p.style.background = color;
        parent.appendChild(p);
      }
    }
  }
}

/* ========= 自機 ========= */
const playerEl = document.getElementById("player");
const SHIP = [
  "0011100",
  "0111110",
  "1111111",
  "1101011",
  "1000001"
];

let shipW, shipH;

/* サイズ変数（宣言位置はここ！） */
let enemyW, enemyH;
let shieldW, shieldH;

const playerBottomPx = 70;
let px = innerWidth/2;

function recalcSizes(){
  shipW   = 7*U;
  shipH   = 5*U;
  enemyW  = 7*U;
  enemyH  = 4*U;
  shieldW = 8*U;
  shieldH = 6*U;
}
recalcSizes();

drawSprite(playerEl, SHIP, playerColor());

function playerTopY(){
  return innerHeight - playerBottomPx - shipH;
}
function updatePlayerPos(){
  px = clamp(px, shipW/2, innerWidth - shipW/2);
  playerEl.style.left = px + "px";
}
updatePlayerPos();

/* ========= 敵 ========= */
const enemies = [];
let cols = getCols();
let rows = getRows();

const ENEMY_TYPES = [
  { a:["0100010","1111111","1011101","0100010"], b:["0100010","1111111","0101010","1010101"] },
  { a:["0011100","0111110","1101011","0111110"], b:["0011100","1111111","0101010","1010101"] },
  { a:["0110110","1111111","0101010","1010101"], b:["0011100","0111110","1101011","0111110"] },
  { a:["0011100","1111111","1010101","0100010"], b:["0011100","0111110","0101010","1010101"] }
];

function enemyProfile(){
  const baseSpeed = 0.55;
  const speed = baseSpeed + (wave-1)*0.05;
  const fireInterval = Math.max(40, Math.floor(140 - (wave-1)*10));
  return { speed, fireInterval };
}

let fx = 0;
let dir = 1;
let enemyAnimTick = 0;
let enemyFrame = 0;
let enemyShootTick = 0;

function formationMetrics(){
  // ★モバイルは横間隔を少し広げて見やすく（8列なので余裕あり）
  const stepX = (isMobile ? 12 : 10) * U;
  const stepY = 7 * U;
  const totalW = (cols-1)*stepX + enemyW;
  const baseY = Math.max(60, innerHeight*0.14);
  return { stepX, stepY, totalW, baseY };
}

function spawnEnemies(){
  enemies.forEach(e=>e.el.remove());
  enemies.length = 0;

  const { stepX, stepY, totalW, baseY } = formationMetrics();

  fx = (innerWidth - totalW)/2;
  dir = 1;

  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const el = document.createElement("div");
      el.className = "enemy";

      const type = ENEMY_TYPES[r % ENEMY_TYPES.length];
      const colorBase = 60 + r*40;
      const col = `rgb(${255-colorBase}, ${120-colorBase/2}, ${120-colorBase/2})`;

      drawSprite(el, type.a, col);
      document.body.appendChild(el);

      enemies.push({
        el,
        type,
        color: col,
        r, c,
        xOff: c*stepX,
        y: baseY + r*stepY,
        x: 0
      });
    }
  }
}

/* ========= シールド ========= */
const shields = [];
const SHIELD = [
  "00111100",
  "01111110",
  "11111111",
  "11111111",
  "11111111",
  "11000011"
];

function spawnShields(){
  shields.forEach(s=>s.el.remove());
  shields.length = 0;

  const baseY = playerTopY() - 80;
  const xs = [0.2, 0.4, 0.6, 0.8];
  const color = shieldColor();

  xs.forEach(p=>{
    const el = document.createElement("div");
    el.className = "shield";

    const x = innerWidth*p - shieldW/2;
    const y = baseY;

    el.style.left = x + "px";
    el.style.top  = y + "px";

    for(let yy=0; yy<SHIELD.length; yy++){
      for(let xx=0; xx<SHIELD[yy].length; xx++){
        if(SHIELD[yy][xx]==="1"){
          const d = document.createElement("div");
          d.className = "px";
          d.style.left = (xx*U) + "px";
          d.style.top  = (yy*U) + "px";
          d.style.background = color;
          el.appendChild(d);
        }
      }
    }

    document.body.appendChild(el);
    shields.push({el, x, y});
  });
}

/* ========= 爆発 ========= */
function boom(x,y){
  for(let i=0;i<10;i++){
    const p = document.createElement("div");
    p.className = "boom";
    p.x=x; p.y=y;
    p.vx=(Math.random()-0.5)*5;
    p.vy=(Math.random()-0.5)*5;
    p.style.left=x+"px"; p.style.top=y+"px";
    document.body.appendChild(p);
    let t=18;
    (function a(){
      p.x+=p.vx; p.y+=p.vy;
      p.style.left=p.x+"px"; p.style.top=p.y+"px";
      if(--t>0) requestAnimationFrame(a);
      else p.remove();
    })();
  }
}

/* ========= 弾 ========= */
const bullets = [];
const ebullets = [];
const BW = 4, BH = 10;

function shoot(){
  if(ready || clearing || over || !canShoot) return;
  canShoot = false;

  const b = document.createElement("div");
  b.className = "b";

  const x = px - BW/2;
  const y = playerTopY();

  b.x = x; b.y = y;
  b.style.left = x + "px";
  b.style.top  = y + "px";

  document.body.appendChild(b);
  bullets.push(b);
}

function enemyShoot(){
  if(ready || clearing || over) return;
  if(!enemies.length) return;

  const e = enemies[Math.floor(Math.random()*enemies.length)];

  const x = e.x + enemyW/2 - BW/2;
  const y = e.y + enemyH;

  const b = document.createElement("div");
  b.className = "eb";
  b.x = x; b.y = y;
  b.style.left = x + "px";
  b.style.top  = y + "px";

  document.body.appendChild(b);
  ebullets.push(b);
}

/* ========= Wave演出 ========= */
function showReady(){
  ready = true;
  safeTimer = Math.floor(wave * 0.5 * 60);
  msgEl.textContent = "READY";
  setTimeout(()=>{
    msgEl.textContent = "";
    ready = false;
  }, 900);
}

function nextWave(){
  clearing = true;
  msgEl.textContent = "CLEAR!";
  setTimeout(()=>{
    msgEl.textContent = "";
    wave++;
    waveEl.textContent = wave;
    clearing = false;

    drawSprite(playerEl, SHIP, playerColor());
    spawnEnemies();
    spawnShields();
    showReady();
  }, 900);
}

function gameOver(){
  if(over) return;
  over = true;
  msgEl.innerHTML = "GAME OVER<br>Tap or Enter";
}

/* ========= リセット ========= */
function reset(){
  bullets.forEach(b=>b.remove()); bullets.length=0;
  ebullets.forEach(b=>b.remove()); ebullets.length=0;
  enemies.forEach(e=>e.el.remove()); enemies.length=0;
  shields.forEach(s=>s.el.remove()); shields.length=0;

  score = 0; wave = 1; life = 3;
  invincible = 0; safeTimer = 0;
  over = false; clearing = false;

  scoreEl.textContent = "0";
  waveEl.textContent  = "1";
  updateLifeHud();

  px = innerWidth/2;
  updatePlayerPos();

  drawSprite(playerEl, SHIP, playerColor());

  cols = getCols();
  rows = getRows();
  spawnEnemies();
  spawnShields();
  showReady();
}

/* ========= 画面サイズ変更で U を更新＋再描画 ========= */
function updateUnitSizeAndRedraw(){
  const newU = calcU();
  const newIsMobile = innerWidth < 800;

  const oldIsMobile = isMobile;
  const oldCols = cols;
  const oldRows = rows;

  // 更新
  U = newU;
  isMobile = newIsMobile;
  cols = getCols();
  rows = getRows();

  document.body.style.setProperty("--u", U);
  recalcSizes();

  // 弾は見た目がズレやすいので一旦クリア
  bullets.forEach(b=>b.remove()); bullets.length=0;
  ebullets.forEach(b=>b.remove()); ebullets.length=0;

  // 自機描き直し
  drawSprite(playerEl, SHIP, playerColor());
  updatePlayerPos();

  // ★モバイル判定 or cols/rows が変わったら、敵は作り直す
  if(oldIsMobile !== isMobile || oldCols !== cols || oldRows !== rows){
    spawnEnemies();
  }else{
    // 敵：xOff/y を新しいU基準で作り直す（行列が同じ時だけ）
    const { stepX, stepY, totalW, baseY } = formationMetrics();
    fx = (innerWidth - totalW)/2;

    for(const e of enemies){
      e.xOff = e.c * stepX;
      e.y    = baseY + e.r * stepY;
      drawSprite(e.el, e.type.a, e.color);
    }
  }

  // 盾：作り直し
  spawnShields();
}

/* ========= 入力 ========= */
addEventListener("keydown", (e)=>{
  if(over && e.key === "Enter") reset();
  if(e.key === "ArrowLeft")  holdL = true;
  if(e.key === "ArrowRight") holdR = true;
  if(e.key === " " || e.key === "a" || e.key === "A") shoot();
});
addEventListener("keyup", (e)=>{
  if(e.key === "ArrowLeft")  holdL = false;
  if(e.key === "ArrowRight") holdR = false;
  if(e.key === " " || e.key === "a" || e.key === "A") canShoot = true;
});

// モバイルコントローラ
document.querySelectorAll(".btn").forEach(btn=>{
  const k = btn.dataset.k;
  btn.addEventListener("touchstart",(e)=>{
    e.preventDefault();
    if(k==="L") holdL=true;
    if(k==="R") holdR=true;
    if(k==="S") shoot();
  },{passive:false});
  btn.addEventListener("touchend",()=>{
    if(k==="L") holdL=false;
    if(k==="R") holdR=false;
    if(k==="S") canShoot=true;
  });
  btn.addEventListener("mousedown",()=>{
    if(k==="L") holdL=true;
    if(k==="R") holdR=true;
    if(k==="S") shoot();
  });
  btn.addEventListener("mouseup",()=>{
    if(k==="L") holdL=false;
    if(k==="R") holdR=false;
    if(k==="S") canShoot=true;
  });
});

addEventListener("touchstart", ()=>{ if(over) reset(); });

/* ========= resize ========= */
addEventListener("resize", ()=>{
  resizeCanvas();
  updateUnitSizeAndRedraw();
});

/* ========= ループ ========= */
function update(){
  // 背景
  ctx.fillStyle="#000";
  ctx.fillRect(0,0,bg.width,bg.height);
  ctx.fillStyle="#fff";
  for(const s of stars){
    s.y += s.s;
    if(s.y>bg.height){ s.y=0; s.x=Math.random()*bg.width; }
    ctx.fillRect(s.x,s.y,2,2);
  }

  if(invincible>0) invincible--;
  if(safeTimer>0) safeTimer--;

  // 自機移動
  const sp = isMobile ? 3 : 4;
  if(!ready && !clearing && !over){
    if(holdL) px -= sp;
    if(holdR) px += sp;
  }
  updatePlayerPos();

  // 敵移動
  const prof = enemyProfile();
  const { totalW } = formationMetrics();

  if(!ready && !clearing && !over){
    fx += dir * prof.speed;
  }

  // 壁反転＋下げ（1回だけ確実に発火させる）
  const margin = 10;
  let hitWall = false;

  const leftEdge = fx;
  const rightEdge = fx + totalW;

  if(!ready && !clearing && !over){
    if (rightEdge > innerWidth - margin) {
      // 右壁に当たった：内側に押し戻してから左へ
      fx = (innerWidth - margin) - totalW;
      dir = -1;
      hitWall = true;
    } else if (leftEdge < margin) {
      // 左壁に当たった：内側に押し戻してから右へ
      fx = margin;
      dir = 1;
      hitWall = true;
    }

    if (hitWall) {
      // 「少し下がる」を見える量に：U基準で
      const wallDrop = 0.6 * U;  // 好みで 0.4〜1.0 * U くらい
      const enemyMaxY = playerTopY() - 120;

      for (const e of enemies) {
        e.y = Math.min(enemyMaxY, e.y + wallDrop);
      }
    }
  }

  // 敵座標更新
  for(const e of enemies){
    e.x = fx + e.xOff;
    e.el.style.left = e.x + "px";
    e.el.style.top  = e.y + "px";
  }

  // 足パタ
  enemyAnimTick++;
  if(enemyAnimTick >= 28){
    enemyAnimTick = 0;
    enemyFrame = 1 - enemyFrame;
    for(const e of enemies){
      drawSprite(e.el, enemyFrame ? e.type.b : e.type.a, e.color);
    }
  }

  // 敵弾
  if(!ready && !clearing && !over){
    enemyShootTick++;
    if(enemyShootTick >= prof.fireInterval){
      enemyShootTick = 0;
      enemyShoot();
    }
  }

  // 自弾移動
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.y -= 10;
    b.style.top = b.y + "px";
    if(b.y < -20){
      b.remove(); bullets.splice(i,1);
    }
  }

  // 敵弾移動
  for(let i=ebullets.length-1;i>=0;i--){
    const b = ebullets[i];
    b.y += (isMobile ? 5 : 7);
    b.style.top = b.y + "px";
    if(b.y > innerHeight + 30){
      b.remove(); ebullets.splice(i,1);
    }
  }

  // 当たり：自弾→敵
  for(let ei=enemies.length-1; ei>=0; ei--){
    const e = enemies[ei];
    for(let bi=bullets.length-1; bi>=0; bi--){
      const b = bullets[bi];
      if(hit(b.x,b.y,BW,BH, e.x,e.y, enemyW,enemyH)){
        boom(e.x + enemyW/2, e.y + enemyH/2);
        e.el.remove(); enemies.splice(ei,1);
        b.remove(); bullets.splice(bi,1);
        score += 100; scoreEl.textContent = score;
        break;
      }
    }
  }

  // 当たり：弾→盾
  function shieldBlock(list){
    for(let bi=list.length-1; bi>=0; bi--){
      const b = list[bi];
      for(const s of shields){
        if(hit(b.x,b.y,BW,BH, s.x,s.y, shieldW,shieldH)){
          const dots = s.el.children;
          if(dots.length){
            dots[Math.floor(Math.random()*dots.length)].remove();
          }
          b.remove(); list.splice(bi,1);
          break;
        }
      }
    }
  }
  shieldBlock(bullets);
  shieldBlock(ebullets);

  // 当たり：敵弾→自機
  if(!over){
    const pxLeft = px - shipW/2;
    const pyTop  = playerTopY();
    for(let bi=ebullets.length-1; bi>=0; bi--){
      const b = ebullets[bi];
      if(hit(b.x,b.y,BW,BH, pxLeft,pyTop, shipW,shipH)){
        b.remove(); ebullets.splice(bi,1);

        if(invincible===0 && safeTimer===0){
          life--;
          updateLifeHud();
          boom(px, pyTop + shipH/2);
          invincible = 60;
          if(life <= 0) gameOver();
        }
      }
    }
  }

  // Waveクリア
  if(!over && !clearing && enemies.length === 0){
    nextWave();
  }

  requestAnimationFrame(update);
}

/* ========= START ========= */
reset();
update();
</script>
</body>
</html>
