<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Typing Pet</title>
  <style>
    :root{
      --bg:#0b1020;
      --text:#eaf0ff;
      --muted:#a8b3d6;
      --line:rgba(255,255,255,.10);
      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Yu Gothic", sans-serif;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: var(--sans);
      background:
        radial-gradient(1200px 800px at 20% 10%, rgba(123,240,255,.16), transparent 60%),
        radial-gradient(1000px 700px at 80% 30%, rgba(181,255,123,.12), transparent 60%),
        radial-gradient(900px 700px at 50% 100%, rgba(255,107,139,.10), transparent 65%),
        linear-gradient(180deg, #070a14, var(--bg));
      color: var(--text);
      overflow-x:hidden;
    }
    .wrap{max-width:1100px;margin:0 auto;padding:22px 16px 40px;}
    header{display:flex;align-items:flex-end;justify-content:space-between;gap:14px;padding:10px 4px 18px;}
    h1{margin:0;font-size:clamp(20px,2.6vw,32px);letter-spacing:.3px;line-height:1.15;}
    .sub{margin:6px 0 0;color:var(--muted);font-size:13px;line-height:1.45;}
    .pillRow{display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end}
    .pill{
      padding:8px 10px;border:1px solid var(--line);
      background:rgba(16,26,51,.55);border-radius:999px;font-size:12px;color:var(--muted);
      display:flex;align-items:center;gap:8px;box-shadow:0 10px 30px rgba(0,0,0,.20);
      backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);user-select:none;
    }
    .dot{
      width:10px;height:10px;border-radius:50%;
      background:rgba(123,240,255,.65);
      box-shadow:0 0 0 3px rgba(123,240,255,.12),0 0 24px rgba(123,240,255,.45);
    }
    .grid{display:grid;grid-template-columns:1.15fr .85fr;gap:16px;}
    @media (max-width:980px){.grid{grid-template-columns:1fr}.pillRow{justify-content:flex-start}}
    .card{
      border:1px solid var(--line);
      background:linear-gradient(180deg, rgba(16,26,51,.85), rgba(14,23,48,.70));
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;position:relative;
    }
    .card h2{
      margin:0;padding:14px 16px;font-size:14px;color:var(--muted);letter-spacing:.4px;
      border-bottom:1px solid var(--line);
      display:flex;align-items:center;justify-content:space-between;gap:10px;
    }
    .card h2 .right{display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:flex-end;}
    .btn{
      appearance:none;border:1px solid rgba(255,255,255,.14);background:rgba(10,16,34,.40);
      color:var(--text);border-radius:12px;padding:8px 10px;font-size:12px;cursor:pointer;
      transition:transform .08s ease, background .2s ease, border-color .2s ease;
      user-select:none;
    }
    .btn:hover{background:rgba(10,16,34,.60);border-color:rgba(123,240,255,.35)}
    .btn:active{transform:translateY(1px)}
    .btn.primary{border-color:rgba(123,240,255,.35);background:rgba(123,240,255,.10);}
    .btn.danger{border-color:rgba(255,107,139,.35);background:rgba(255,107,139,.10);}
    .body{padding:14px 16px 16px;}
    canvas{
      width:100%;height:380px;display:block;
      background:
        radial-gradient(900px 400px at 50% 20%, rgba(123,240,255,.10), transparent 65%),
        radial-gradient(600px 300px at 20% 80%, rgba(181,255,123,.08), transparent 60%),
        linear-gradient(180deg, rgba(7,10,20,.55), rgba(7,10,20,.20));
      border-bottom:1px solid var(--line);
    }
    .petFooter{display:flex;gap:12px;flex-wrap:wrap;padding:12px 16px 16px;align-items:center;justify-content:space-between;}
    .statLine{display:flex;gap:10px;flex-wrap:wrap;align-items:center;color:var(--muted);font-size:12px;}
    .tag{padding:6px 10px;border:1px solid rgba(255,255,255,.12);border-radius:999px;background:rgba(0,0,0,.18);color:var(--muted);font-size:12px;}
    .tag b{color:var(--text);font-weight:600}
    .meter{height:9px;width:180px;border-radius:999px;overflow:hidden;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.20);}
    .meter>i{display:block;height:100%;width:30%;background:linear-gradient(90deg, rgba(123,240,255,.75), rgba(181,255,123,.70));box-shadow:0 0 24px rgba(123,240,255,.35);}

    .typingBox{display:flex;flex-direction:column;gap:12px;}
    .prompt{
      padding:12px 12px;border:1px dashed rgba(255,255,255,.14);border-radius:14px;background:rgba(0,0,0,.16);
      line-height:1.8;font-size:14px;
    }
    .promptLine{
      font-family:var(--mono);
      font-size:15px;
      letter-spacing:.2px;
      word-break:break-word;
      white-space:pre-wrap;
    }
    .ch{
      display:inline-block;
      padding:0 0.5px;
      border-radius:6px;
      transition:background .08s ease, color .08s ease, box-shadow .08s ease;
    }
    .todo{ color: rgba(234,240,255,.55); }
    .ok{ color: rgba(181,255,123,.95); text-shadow: 0 0 18px rgba(181,255,123,.18); }
    .bad{ color: rgba(255,107,139,.95); background: rgba(255,107,139,.10); box-shadow: 0 0 0 1px rgba(255,107,139,.22) inset; }
    .caret{ position:relative; }
    .caret::after{
      content:"";
      position:absolute; left:-1px; bottom:-2px;
      width:2px; height:1.25em;
      background: rgba(123,240,255,.75);
      border-radius:2px;
      box-shadow: 0 0 18px rgba(123,240,255,.35);
      animation: blink 1s step-end infinite;
    }
    @keyframes blink { 50% { opacity: 0; } }

    .inputRow{display:flex;gap:10px;flex-wrap:wrap;align-items:center;}
    input[type="text"]{
      flex:1;min-width:220px;padding:12px 12px;border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(10,16,34,.45);color:var(--text);outline:none;font-family:var(--mono);
      font-size:14px;letter-spacing:.2px;
      ime-mode: disabled;
    }
    input[type="text"]:focus{border-color:rgba(123,240,255,.45);box-shadow:0 0 0 3px rgba(123,240,255,.12);}
    .mini{color:var(--muted);font-size:12px;line-height:1.5;}
    .cols{display:grid;grid-template-columns:1fr 1fr;gap:12px;}
    @media (max-width:520px){.cols{grid-template-columns:1fr}.meter{width:140px;}}
    .kv{border:1px solid var(--line);border-radius:14px;padding:12px;background:rgba(0,0,0,.14);}
    .kv .k{color:var(--muted);font-size:12px}
    .kv .v{margin-top:6px;font-size:16px;font-weight:700}
    .log{height:220px;overflow:auto;padding-right:6px;}
    .logItem{padding:10px 10px;border:1px solid rgba(255,255,255,.10);border-radius:14px;background:rgba(0,0,0,.14);margin-bottom:10px;font-size:13px;line-height:1.5;}
    .logItem .t{color:var(--muted);font-size:11px;margin-bottom:4px}
    .logItem.good{border-color:rgba(181,255,123,.20)}
    .logItem.bad{border-color:rgba(255,107,139,.22)}
    .logItem.info{border-color:rgba(123,240,255,.20)}
    footer{margin-top:14px;color:rgba(255,255,255,.52);font-size:12px;padding:12px 4px;}

    .toast{
      position:fixed;left:50%;bottom:16px;transform:translateX(-50%);
      background:rgba(10,16,34,.88);border:1px solid rgba(255,255,255,.16);
      border-radius:999px;padding:10px 14px;color:var(--text);font-size:12px;
      box-shadow:0 20px 70px rgba(0,0,0,.50);
      opacity:0;pointer-events:none;transition:opacity .18s ease, transform .18s ease;
      z-index:9999;backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);white-space:nowrap;
    }
    .toast.show{opacity:1;transform:translateX(-50%) translateY(-6px);}
    .kbd{font-family:var(--mono);border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.06);padding:2px 6px;border-radius:8px;font-size:12px;color:var(--text);}

    .shake{animation: shake .18s linear 1;}
    @keyframes shake{
      0%{transform:translateX(0)}
      25%{transform:translateX(-2px)}
      50%{transform:translateX(2px)}
      75%{transform:translateX(-1px)}
      100%{transform:translateX(0)}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Typing Pet ğŸ§« è¬ã®ç”Ÿç‰©ã‚’è‚²ã¦ã‚‹ <span style="opacity:.7;font-size:.7em">(Travel + 10k / Loud Typewriter)</span></h1>
        <p class="sub">
          æ—…è¡Œäºˆç´„ãƒ»å¤‰æ›´ãƒ»ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã§ä½¿ãˆã‚‹è‹±èªã‚’ç·´ç¿’ã€‚<span class="kbd">Enter</span>ã§åˆ¤å®šã€‚<span class="kbd">Esc</span>ã§å…¥åŠ›ãƒªã‚»ãƒƒãƒˆã€‚
        </p>
      </div>
      <div class="pillRow">
        <div class="pill"><span class="dot"></span><span id="statusPill">idle</span></div>
        <div class="pill">Theme: travel</div>
        <div class="pill">Prompts: 10,000 (no-repeat)</div>
        <div class="pill">Sound: louder</div>
      </div>
    </header>

    <div class="grid">
      <section class="card">
        <h2>
          <span>ç”Ÿç‰©è¦³å¯Ÿ</span>
          <span class="right">
            <button class="btn primary" id="btnSnapshot">PNGä¿å­˜</button>
            <button class="btn" id="btnShare">ã‚·ã‚§ã‚¢æ–‡ã‚³ãƒ”ãƒ¼</button>
            <button class="btn danger" id="btnReset">åˆæœŸåŒ–</button>
          </span>
        </h2>
        <canvas id="cv" width="980" height="420"></canvas>
        <div class="petFooter">
          <div class="statLine">
            <span class="tag">Name: <b id="petName"></b></span>
            <span class="tag">Stage: <b id="petStage"></b></span>
            <span class="tag">Mood: <b id="petMood"></b></span>
          </div>
          <div class="statLine">
            <span class="tag">Energy</span>
            <span class="meter"><i id="energyBar"></i></span>
            <span class="tag">Lv <b id="petLv"></b></span>
          </div>
        </div>
      </section>

      <section class="card">
        <h2>
          <span>è‚²æˆã‚¿ã‚¤ãƒ”ãƒ³ã‚°</span>
          <span class="right">
            <button class="btn" id="btnNewPrompt">ãŠé¡Œã‚’å¤‰ãˆã‚‹</button>
          </span>
        </h2>
        <div class="body typingBox">
          <div class="prompt">
            <div id="promptText" class="promptLine"></div>
            <div class="mini" style="margin-top:8px">
              â€» ãƒ–ãƒ©ã‚¦ã‚¶ã‹ã‚‰IMEã‚’å¼·åˆ¶çš„ã«åŠè§’è‹±æ•°ã¸åˆ‡æ›¿ã¯ã§ãã¾ã›ã‚“ã€‚æ—¥æœ¬èªå…¥åŠ›ãŒæœ‰åŠ¹ãªå ´åˆã¯è‹±æ•°ã«åˆ‡ã‚Šæ›¿ãˆã¦ãã ã•ã„ã€‚
            </div>
            <div class="mini" style="margin-top:6px">
              â€» iPhoneç­‰ã§ã¯æœ€åˆã®æ“ä½œãŒå¿…è¦ã§ã™ã€‚éŸ³ãŒå‡ºãªã„ã¨ãã¯å…¥åŠ›æ¬„ã‚’ä¸€åº¦ã‚¿ãƒƒãƒ—ã—ã¦ã‹ã‚‰ã‚¿ã‚¤ãƒ—ã—ã¦ãã ã•ã„ã€‚
            </div>
          </div>

          <div class="inputRow">
            <input id="typeInput" type="text"
              autocomplete="off" autocapitalize="none" autocorrect="off" spellcheck="false"
              inputmode="latin" lang="en"
              placeholder="ä¸Šã®è‹±æ–‡ã‚’ãã®ã¾ã¾å…¥åŠ›ã—ã¦ Enterâ€¦" />
            <button class="btn primary" id="btnSubmit">Enteråˆ¤å®š</button>
          </div>

          <div class="cols">
            <div class="kv">
              <div class="k">WPM (ç›´è¿‘)</div>
              <div class="v"><span id="wpmNow">-</span></div>
              <div class="mini">é€Ÿã„ã»ã©æ´»ç™ºã«ã€‚é…ã„ã¨çœ ããªã‚‹ã€‚</div>
            </div>
            <div class="kv">
              <div class="k">Accuracy (ç›´è¿‘)</div>
              <div class="v"><span id="accNow">-</span>%</div>
              <div class="mini">ãƒŸã‚¹ãŒå¤šã„ã¨å°–ã‚Šã€æš´ã‚Œã‚„ã™ã„ã€‚</div>
            </div>
            <div class="kv">
              <div class="k">Combo</div>
              <div class="v"><span id="comboNow">0</span></div>
              <div class="mini">é€£ç¶šæˆåŠŸã§æ€¥æˆé•·ã€‚é€”åˆ‡ã‚Œã‚‹ã¨è½ã¡ç€ãã€‚</div>
            </div>
            <div class="kv">
              <div class="k">Trait</div>
              <div class="v" id="traitNow">-</div>
              <div class="mini">ã‚ãªãŸã®æ‰“ã¡æ–¹ãŒæ€§æ ¼ã‚’ä½œã‚‹ã€‚</div>
            </div>
          </div>

          <div class="kv">
            <div class="k">è‚²æˆãƒ­ã‚°</div>
            <div class="log" id="log"></div>
          </div>

          <div class="mini">
            IMEå¤‰æ›ä¸­ï¼ˆcompositionä¸­ï¼‰ã¯è‰²æ›´æ–°ã¨ã‚¿ã‚¤ãƒ—éŸ³ã‚’æŠ‘åˆ¶ã—ã¾ã™ã€‚
          </div>
        </div>
      </section>
    </div>

    <footer>
      æ—…è¡Œäºˆç´„ã®æ–‡ç« ã‚’ä¸­å¿ƒã«10,000ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆé‡è¤‡ãªã—ï¼‰ã€‚å…¥åŠ›ã”ã¨ã«ä¸Šã®è‹±æ–‡ãŒ1æ–‡å­—ãšã¤è‰²å¤‰åŒ–ã€‚ã‚¿ã‚¤ãƒ—ãƒ©ã‚¤ã‚¿ãƒ¼éŸ³ã¯Web Audioã§ç”Ÿæˆï¼ˆéŸ³é‡UPï¼‰ã€‚
    </footer>
  </div>

  <div class="toast" id="toast">copied</div>

<script>
(() => {
  const $ = (sel) => document.querySelector(sel);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const now = () => Date.now();
  const fmtTime = (ms) => {
    const d = new Date(ms);
    const hh = String(d.getHours()).padStart(2,'0');
    const mm = String(d.getMinutes()).padStart(2,'0');
    const ss = String(d.getSeconds()).padStart(2,'0');
    return `${hh}:${mm}:${ss}`;
  };
  const pick = (arr) => arr[(Math.random()*arr.length)|0];
  const hash32 = (str) => {
    let h = 2166136261;
    for (let i=0;i<str.length;i++){
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h >>> 0;
  };
  const lerp = (a,b,t) => a + (b-a)*t;
  const escapeHtml = (s) =>
    String(s).replace(/[&<>"']/g, c => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[c]));

  // ===== Typewriter Sound (LOUD DEFAULT) =====
  const TypeSound = (() => {
    let ctx = null;
    let out = null;
    let unlocked = false;

    function ensure() {
      if (!ctx) {
        ctx = new (window.AudioContext || window.webkitAudioContext)();
        out = ctx.createGain();
        out.gain.value = 0.85; // â˜…ã“ã“ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆéŸ³é‡ï¼ˆå¤§ãã‚ï¼‰
        out.connect(ctx.destination);
      }
    }

    async function unlock() {
      try {
        ensure();
        if (ctx.state === "suspended") await ctx.resume();
        unlocked = true;
        click({ a: 0.00001, t: 0.01, band: 1500, q: 8 });
      } catch (e) {}
    }

    function click({ a = 0.09, t = 0.016, band = 1900, q = 9 } = {}) {
      if (!unlocked) return;
      ensure();
      const sr = ctx.sampleRate;
      const len = Math.max(32, Math.floor(sr * t));
      const buf = ctx.createBuffer(1, len, sr);
      const data = buf.getChannelData(0);
      for (let i = 0; i < len; i++) {
        const d = 1 - i / len;
        data[i] = (Math.random() * 2 - 1) * (d * d);
      }

      const src = ctx.createBufferSource();
      src.buffer = buf;

      const bp = ctx.createBiquadFilter();
      bp.type = "bandpass";
      bp.frequency.value = band;
      bp.Q.value = q;

      const g = ctx.createGain();
      const t0 = ctx.currentTime;
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(Math.max(0.0001, a), t0 + 0.003);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + t);

      src.connect(bp);
      bp.connect(g);
      g.connect(out);

      src.start(t0);
      src.stop(t0 + t + 0.02);
    }

    function type(kind = "char") {
      if (!unlocked) return;

      if (kind === "backspace") {
        click({ a: 0.12, t: 0.020, band: 900, q: 6 });
        setTimeout(() => click({ a: 0.07, t: 0.014, band: 700, q: 6 }), 10);
        return;
      }
      if (kind === "space") {
        click({ a: 0.10, t: 0.016, band: 1200, q: 7 });
        return;
      }
      // normal
      click({ a: 0.10, t: 0.014, band: 2000, q: 10 });
      if (Math.random() < 0.35) setTimeout(() => click({ a: 0.06, t: 0.011, band: 2600, q: 10 }), 8);
    }

    return { unlock, type };
  })();

  // ----- Prompts (10k, travel only) -----
  const PROMPT_COUNT = 10000;

  function makeOrder(n, seed){
    let x = (seed >>> 0) || 123456789;
    const rnd = () => (x = (x * 1664525 + 1013904223) >>> 0) / 4294967296;
    const arr = Array.from({length:n}, (_,i)=>i);
    for(let i=n-1;i>0;i--){
      const j = (rnd() * (i+1)) | 0;
      const tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;
    }
    return arr;
  }

  function ensureOrder(state){
    state.prompts = state.prompts || {};
    const bag = state.prompts.travel || (state.prompts.travel = {});
    if(!bag.order || !Array.isArray(bag.order) || bag.order.length !== PROMPT_COUNT){
      const seed = (state.seed || 0) ^ hash32(state.name + "::travel");
      bag.order = makeOrder(PROMPT_COUNT, seed);
      bag.pos = 0;
      bag.cycle = 0;
    }
    return bag;
  }

  function nextPromptIndex(state){
    const bag = ensureOrder(state);
    const idx = bag.order[bag.pos];
    bag.pos = (bag.pos + 1) % PROMPT_COUNT;
    if(bag.pos === 0){
      bag.cycle = (bag.cycle || 0) + 1;
      const seed2 = ((state.seed || 0) + (bag.cycle||1)) ^ hash32(state.name + "::travel::cycle");
      bag.order = makeOrder(PROMPT_COUNT, seed2);
      bag.pos = 0;
    }
    return idx;
  }

  function mixedRadixPick(i, bases){
    let x = i;
    const out = [];
    for(let k=bases.length-1;k>=0;k--){
      const b = bases[k];
      out[k] = x % b;
      x = (x / b) | 0;
    }
    return out;
  }

  const TRAVEL = {
    OPEN: ["hello,","hi there,","good morning,","good afternoon,","excuse me,","i have a question.","i need help.","could you help me,","i would like to check something.","i am calling about a reservation.","i am emailing about my booking.","i need to update my booking."],
    INTENT: ["i would like to book","i would like to reserve","i need to change","i need to modify","i need to cancel","i would like to confirm","i would like to rebook","i need to extend","i need to shorten","i need to add","i need to remove","i need to correct"],
    WHAT: ["a hotel room","a flight","a train ticket","a rental car","an airport transfer","a tour","a reservation","my booking","my itinerary","my seat","my check-in date","my guest name"],
    DETAILS: ["for one person","for two people","for three people","for two adults and one child","with breakfast included","with a non-smoking room","with a double bed","with a late check-out","with free cancellation","with checked baggage","with a window seat if possible","with a child seat","with an automatic transmission","with insurance included","with an ocean view if available","and i have a confirmation number"],
    DATE: ["from march 3 to march 5","from march 12 to march 14","from april 1 to april 4","from april 10 to april 12","from may 2 to may 6","from may 18 to may 20","on june 7","on june 21","on july 3","on july 19","on august 9","on september 2","next monday","next friday","this weekend","tomorrow","today","in the evening","in the morning","around 3 pm"],
    EXTRA: ["could you confirm the total price","could you confirm the cancellation policy","could you send me the updated confirmation","could you tell me what documents i need","could you check availability","could you recommend the best option","could you confirm the check-in time","could you confirm the baggage allowance","could you help me change the dates","could you help me change the name on the reservation","could you help me add another guest","could you help me change the payment method","could you confirm the pickup location","could you confirm the drop-off time","could you help me choose seats","could you tell me if there is an extra fee"]
  };

  function promptByIndex(i){
    const bases = [TRAVEL.OPEN.length, TRAVEL.INTENT.length, TRAVEL.WHAT.length, TRAVEL.DETAILS.length, TRAVEL.DATE.length, TRAVEL.EXTRA.length];
    const [a,b,c,d,e,f] = mixedRadixPick(i, bases);
    const open = TRAVEL.OPEN[a];
    const intent = TRAVEL.INTENT[b];
    const what = TRAVEL.WHAT[c];
    const details = TRAVEL.DETAILS[d];
    const date = TRAVEL.DATE[e];
    const extra = TRAVEL.EXTRA[f];
    const core = `${intent} ${what} ${details} ${date}.`;
    return `${open} ${core} ${extra}?`;
  }

  // ----- State -----
  const STORAGE_KEY = "typing_pet_state_travel_only_typewriter_loud_v1";
  const defaultState = () => ({
    name: generateName(),
    createdAt: now(),
    lastSeen: now(),
    lv: 1, xp: 0, stage: 0,
    energy: 0.72, mood: 0.55, glow: 0.45, spikes: 0.25, wobble: 0.35, friendliness: 0.55,
    trait: "balanced",
    combo: 0,
    wpmNow: null, accNow: null,
    seed: (Math.random()*1e9)|0,
    log: [],
    prompts: {},
    promptIndex: null
  });

  function generateName(){
    const a = ["Myo","Nya","Zuo","Kiri","Peko","Vivi","Lumo","Rabi","Mimi","Sora","Dodo","Koko","Noro","Puru","Mogu"];
    const b = ["blob","mite","ling","core","seed","goo","puff","wisp","morph","bud","nug","sprout","gazer","drift","node"];
    return pick(a) + pick(b);
  }
  function loadState(){ try{ const raw = localStorage.getItem(STORAGE_KEY); if(!raw) return null; const s = JSON.parse(raw); return (s && typeof s==="object") ? s : null; }catch(e){ return null; } }
  function saveState(){ try{ state.lastSeen = now(); localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }catch(e){} }

  // ----- Elements -----
  const cv = $("#cv");
  const ctx = cv.getContext("2d");
  const toastEl = $("#toast");
  const el = {
    statusPill: $("#statusPill"),
    petName: $("#petName"),
    petStage: $("#petStage"),
    petMood: $("#petMood"),
    petLv: $("#petLv"),
    energyBar: $("#energyBar"),
    promptText: $("#promptText"),
    typeInput: $("#typeInput"),
    btnSubmit: $("#btnSubmit"),
    btnNewPrompt: $("#btnNewPrompt"),
    btnSnapshot: $("#btnSnapshot"),
    btnShare: $("#btnShare"),
    btnReset: $("#btnReset"),
    wpmNow: $("#wpmNow"),
    accNow: $("#accNow"),
    comboNow: $("#comboNow"),
    traitNow: $("#traitNow"),
    log: $("#log"),
  };

  // ----- Toast & Log -----
  function toast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add("show");
    clearTimeout(toast._t);
    toast._t = setTimeout(()=>toastEl.classList.remove("show"), 1100);
  }
  function pushLog(kind, msg){
    const item = { t: now(), kind, msg };
    state.log = state.log || [];
    state.log.unshift(item);
    state.log = state.log.slice(0, 60);
    renderLog();
    saveState();
  }
  function renderLog(){
    el.log.innerHTML = "";
    (state.log||[]).forEach(it=>{
      const div = document.createElement("div");
      div.className = `logItem ${it.kind||"info"}`;
      div.innerHTML = `<div class="t">${fmtTime(it.t)}</div><div>${escapeHtml(it.msg)}</div>`;
      el.log.appendChild(div);
    });
  }

  // ----- Pet helpers -----
  function stageName(stage){ return ["èŠ½ç”Ÿãˆ","ã·ã‚‹ã·ã‚‹","ç™ºå…‰ä½“","å¤šè„šä½“","æœªçŸ¥ä½“"][clamp(stage,0,4)]; }
  function moodName(m){ if(m < 0.25) return "calm"; if(m < 0.55) return "curious"; if(m < 0.80) return "wild"; return "feral"; }
  function traitFrom(s){
    const { friendliness, glow, spikes, wobble } = s;
    if (friendliness > 0.68 && spikes < 0.45) return "gentle";
    if (glow > 0.70 && friendliness > 0.55) return "radiant";
    if (spikes > 0.72 && friendliness < 0.50) return "spiky";
    if (wobble > 0.70) return "jelly";
    return "balanced";
  }

  // ----- Init -----
  let state = loadState() || defaultState();
  (function migrate(){
    const d = defaultState();
    for(const k in d){ if(state[k] === undefined) state[k] = d[k]; }
    state.log = state.log || [];
    state.prompts = state.prompts || {};
    state.energy = clamp(state.energy ?? 0.7, 0, 1);
    state.mood = clamp(state.mood ?? 0.55, 0, 1);
    state.glow = clamp(state.glow ?? 0.45, 0, 1);
    state.spikes = clamp(state.spikes ?? 0.25, 0, 1);
    state.wobble = clamp(state.wobble ?? 0.35, 0, 1);
    state.friendliness = clamp(state.friendliness ?? 0.55, 0, 1);
  })();

  const awayMs = now() - (state.lastSeen || now());
  if (awayMs > 10_000) {
    const mins = awayMs / 60000;
    const rec = clamp(mins * 0.015, 0, 0.18);
    state.energy = clamp((state.energy ?? 0.7) + rec, 0, 1);
    state.log.unshift({t: now(), kind:"info", msg:`ç•™å®ˆä¸­ã«ã‚¨ãƒãƒ«ã‚®ãƒ¼ãŒå°‘ã—å›å¾©ã—ãŸ (+${Math.round(rec*100)}%).`});
    state.log = state.log.slice(0,60);
  }

  // ----- Typing session -----
  let session = { startedAt: null, lastKeyAt: null, typed: "", target: "", idle: true };
  let composing = false;
  let lastKeyKind = "char";

  // ----- Prompt rendering -----
  let promptChars = [];
  function renderPromptChars(text){
    el.promptText.innerHTML = "";
    promptChars = [];
    for(let i=0;i<text.length;i++){
      const span = document.createElement("span");
      span.className = "ch todo";
      const ch = text[i];
      span.textContent = (ch === " ") ? "\u00A0" : ch;
      el.promptText.appendChild(span);
      promptChars.push(span);
    }
    updatePromptHighlight("");
  }
  function updatePromptHighlight(typed){
    const target = session.target || "";
    const tLen = target.length;
    const uLen = typed.length;

    const min = Math.min(tLen, promptChars.length);
    for(let i=0;i<min;i++){
      const sp = promptChars[i];
      sp.classList.remove("ok","bad","todo","caret");
      if(i < uLen){
        sp.classList.add(typed[i] === target[i] ? "ok" : "bad");
      }else{
        sp.classList.add("todo");
      }
    }
    const caretPos = clamp(uLen, 0, Math.max(0, tLen-1));
    if(promptChars[caretPos]) promptChars[caretPos].classList.add("caret");
  }
  function shakePrompt(){
    el.promptText.classList.remove("shake");
    void el.promptText.offsetWidth;
    el.promptText.classList.add("shake");
  }

  // ----- UI -----
  function updateHeaderUI(){
    $("#petName").textContent = state.name;
    $("#petStage").textContent = stageName(state.stage);
    $("#petMood").textContent = moodName(state.mood);
    $("#petLv").textContent = state.lv;
    $("#energyBar").style.width = `${Math.round(state.energy*100)}%`;

    $("#wpmNow").textContent = state.wpmNow == null ? "-" : String(state.wpmNow);
    $("#accNow").textContent = state.accNow == null ? "-" : String(Math.round(state.accNow*100));
    $("#comboNow").textContent = String(state.combo || 0);

    state.trait = traitFrom(state);
    $("#traitNow").textContent = state.trait;

    $("#statusPill").textContent = session.idle ? "idle" : "awake";
  }

  function setPrompt(index=null){
    const idx = (index == null) ? nextPromptIndex(state) : index;
    state.promptIndex = idx;
    session.target = promptByIndex(idx);

    renderPromptChars(session.target);

    el.typeInput.value = "";
    session.typed = "";
    session.startedAt = null;
    session.lastKeyAt = null;
    session.idle = true;

    updateHeaderUI();
    saveState();
  }

  // ----- Metrics -----
  function computeAccuracy(typed, target){
    const n = Math.max(typed.length, target.length);
    if(n === 0) return 1;
    let same = 0;
    for(let i=0;i<n;i++){ if(typed[i] === target[i]) same++; }
    return same / n;
  }
  function computeWPM(typed, durationMs){
    if(!durationMs || durationMs <= 0) return 0;
    const minutes = durationMs / 60000;
    return (typed.length / 5) / minutes;
  }
  function levelNeed(lv){
    return Math.round(24 + lv*10 + Math.pow(lv,1.25)*5);
  }

  function rewardFrom(wpm, acc){
    const w = clamp(wpm / 90, 0, 1);
    const a = clamp((acc - 0.6) / 0.4, 0, 1);
    const quality = 0.55*w + 0.45*a;

    const baseXp = 6 + Math.round(quality * 18);
    const combo = state.combo || 0;
    const comboBonus = Math.round(clamp(combo,0,15) * 0.9);
    const xpGain = baseXp + comboBonus;

    const energyCost = 0.04 + (1-a)*0.07 + w*0.02;

    const moodDelta = (w*0.10) - (a*0.08);
    const glowDelta = (quality*0.08) - (Math.abs(w-a)*0.03);
    const spikeDelta = (1-a)*0.12 - a*0.02;
    const wobbleDelta = (w*0.05) + (Math.abs(0.5-(w*0.5+a*0.5))*0.03);
    const friendlyDelta = (a*0.07) - (w*0.03) - ((1-a)*0.03);

    let kind = "info";
    let msg = "";
    if(acc >= 0.95 && wpm >= 50){ kind = "good"; msg = "ãã‚Œã„ã«æ‰“ã¦ãŸï¼ ç”Ÿç‰©ãŒå¬‰ã—ãã†ã«å…‰ã£ãŸã€‚"; }
    else if(acc < 0.75){ kind = "bad"; msg = "ãƒŸã‚¹ãŒå¤šã„â€¦ç”Ÿç‰©ãŒãƒˆã‚²ãƒˆã‚²ã—ã¦ããŸã€‚"; }
    else if(wpm < 25){ kind = "info"; msg = "ã‚†ã£ãã‚Šã§ã‚‚OKã€‚ç”Ÿç‰©ã¯è½ã¡ç€ã„ã¦è¦³å¯Ÿã—ã¦ã„ã‚‹ã€‚"; }
    else { kind = "good"; msg = "ã„ã„èª¿å­ã€‚å°‘ã—æˆé•·ã—ãŸã€‚"; }

    return {
      xpGain,
      energyDelta: -energyCost,
      moodDelta, glowDelta, spikeDelta, wobbleDelta, friendlyDelta,
      msg, kind
    };
  }

  function applyReward(wpm, acc){
    const r = rewardFrom(wpm, acc);
    const pass = (acc >= 0.86);
    state.combo = pass ? (state.combo||0) + 1 : 0;

    state.xp += r.xpGain;
    state.energy = clamp(state.energy + r.energyDelta, 0, 1);
    state.mood = clamp(state.mood + r.moodDelta, 0, 1);
    state.glow = clamp(state.glow + r.glowDelta, 0, 1);
    state.spikes = clamp(state.spikes + r.spikeDelta, 0, 1);
    state.wobble = clamp(state.wobble + r.wobbleDelta, 0, 1);
    state.friendliness = clamp(state.friendliness + r.friendlyDelta, 0, 1);

    state.wpmNow = Math.round(wpm);
    state.accNow = acc;
    state.trait = traitFrom(state);

    pushLog(r.kind, `${r.msg} (+XP ${r.xpGain}, Acc ${Math.round(acc*100)}%, WPM ${Math.round(wpm)})`);

    while(state.xp >= levelNeed(state.lv)){
      state.xp -= levelNeed(state.lv);
      state.lv++;
      pushLog("good", `ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ï¼ Lv ${state.lv} ã«ãªã£ãŸã€‚`);
      state.energy = clamp(state.energy + 0.12, 0, 1);

      const newStage = Math.min(4, Math.floor((state.lv-1)/4));
      if(newStage !== state.stage){
        state.stage = newStage;
        pushLog("good", `é€²åŒ–ï¼ å§¿ãŒã€Œ${stageName(state.stage)}ã€ã«ãªã£ãŸã€‚`);
      }
    }

    if(state.energy <= 0.02) pushLog("bad", "ç–²ã‚Œåˆ‡ã£ãŸâ€¦å°‘ã—ä¼‘ã¾ã›ã¦ã‚ã’ã‚ˆã†ï¼ˆæ”¾ç½®ã§å›å¾©ï¼‰ã€‚");
    saveState();
  }

  // ----- IME events -----
  el.typeInput.addEventListener("compositionstart", () => {
    composing = true;
    toast("IMEå¤‰æ›ä¸­â€¦ è‹±æ•°å…¥åŠ›ã«åˆ‡ã‚Šæ›¿ãˆã¦ãã ã•ã„");
  });
  el.typeInput.addEventListener("compositionend", () => {
    composing = false;
    session.typed = el.typeInput.value;
    updatePromptHighlight(session.typed);
  });

  // ----- Input events -----
  function startSessionIfNeeded(){
    if(session.startedAt == null){
      session.startedAt = now();
      session.idle = false;
      updateHeaderUI();
    }
  }

  el.typeInput.addEventListener("keydown", (e) => {
    TypeSound.unlock();

    if(e.key === "Enter"){ e.preventDefault(); submit(); return; }
    if(e.key === "Escape"){
      e.preventDefault();
      el.typeInput.value = "";
      session.typed = "";
      updatePromptHighlight("");
      toast("ãƒªã‚»ãƒƒãƒˆ");
      return;
    }

    startSessionIfNeeded();
    session.lastKeyAt = now();

    if(e.isComposing || composing) return;

    if(e.key === "Backspace") lastKeyKind = "backspace";
    else if(e.key === " ") lastKeyKind = "space";
    else if(e.key.length === 1) lastKeyKind = "char";
    else lastKeyKind = "other";
  });

  el.typeInput.addEventListener("input", (e) => {
    startSessionIfNeeded();
    session.lastKeyAt = now();

    session.typed = el.typeInput.value;

    if(e.isComposing || composing) return;

    updatePromptHighlight(session.typed);

    const target = session.target || "";
    if(session.typed.length > target.length) shakePrompt();

    const inputType = e.inputType || "";
    if(inputType.startsWith("delete")) TypeSound.type("backspace");
    else if(lastKeyKind === "space") TypeSound.type("space");
    else if(lastKeyKind === "char") TypeSound.type("char");
  });

  window.addEventListener("pointerdown", () => TypeSound.unlock(), { once:true, passive:true });
  window.addEventListener("touchstart", () => TypeSound.unlock(), { once:true, passive:true });
  window.addEventListener("keydown", () => TypeSound.unlock(), { once:true });

  function submit(){
    const typed = (el.typeInput.value || "");
    const target = (session.target || "");
    if(!target){ setPrompt(null); return; }
    if(typed.length === 0){ toast("å…¥åŠ›ã—ã¦ Enter"); return; }

    const endAt = now();
    const startAt = session.startedAt ?? (endAt - 1200);
    const durationMs = Math.max(200, endAt - startAt);
    const acc = computeAccuracy(typed, target);
    const wpm = computeWPM(typed, durationMs);

    applyReward(wpm, acc);

    toast(`${(acc >= 0.86) ? "OK" : "MISS"}  Acc ${Math.round(acc*100)}%  WPM ${Math.round(wpm)}`);
    setPrompt(null);

    if(state.energy < 0.18) pushLog("bad", "ã¡ã‚‡ã£ã¨ç–²ã‚Œã¦ã‚‹â€¦ä¼‘æ†©ã—ãªãŒã‚‰è‚²ã¦ã‚ˆã†ã€‚");
    else if(state.combo >= 5) pushLog("good", `ã‚³ãƒ³ãƒœ ${state.combo}ï¼ ã©ã‚“ã©ã‚“å­¦ç¿’ã—ã¦ã„ã‚‹ã€‚`);
  }

  // ----- Buttons -----
  el.btnNewPrompt.addEventListener("click", () => { setPrompt(null); pushLog("info", "ãŠé¡Œã‚’å¤‰ãˆãŸã€‚æ–°ã—ã„æ—…ã®äºˆå®šã ã€‚"); TypeSound.unlock(); });
  el.btnSubmit.addEventListener("click", () => { TypeSound.unlock(); submit(); });

  el.btnSnapshot.addEventListener("click", () => {
    const a = document.createElement("a");
    a.download = `${state.name}_lv${state.lv}.png`;
    a.href = cv.toDataURL("image/png");
    a.click();
    toast("PNGä¿å­˜");
    pushLog("info", "è¦³å¯Ÿè¨˜éŒ²ï¼ˆPNGï¼‰ã‚’ä¿å­˜ã—ãŸã€‚");
    TypeSound.unlock();
  });

  el.btnShare.addEventListener("click", async () => {
    const text = [
      `Typing Pet (travel booking)`,
      `Name: ${state.name}`,
      `Lv: ${state.lv} / Stage: ${stageName(state.stage)} / Trait: ${state.trait}`,
      `Energy: ${Math.round(state.energy*100)}% / Mood: ${moodName(state.mood)}`,
      `Last: Acc ${state.accNow==null ? "-" : Math.round(state.accNow*100)+"%"} , WPM ${state.wpmNow==null ? "-" : state.wpmNow}`,
      `#TypingPet`
    ].join("\n");
    try{
      await navigator.clipboard.writeText(text);
      toast("ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ");
    }catch(e){
      const ta = document.createElement("textarea");
      ta.value = text; document.body.appendChild(ta);
      ta.select(); document.execCommand("copy");
      document.body.removeChild(ta);
      toast("ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ");
    }
    pushLog("info", "ã‚·ã‚§ã‚¢æ–‡ã‚’ã‚³ãƒ”ãƒ¼ã—ãŸã€‚");
    TypeSound.unlock();
  });

  el.btnReset.addEventListener("click", () => {
    if(!confirm("æœ¬å½“ã«åˆæœŸåŒ–ã—ã¾ã™ã‹ï¼Ÿï¼ˆã“ã®ç«¯æœ«ã®è‚²æˆãƒ‡ãƒ¼ã‚¿ãŒæ¶ˆãˆã¾ã™ï¼‰")) return;
    localStorage.removeItem(STORAGE_KEY);
    state = defaultState();
    stars = null;
    setPrompt(null);
    renderLog();
    updateHeaderUI();
    pushLog("info", "æ–°ã—ã„å€‹ä½“ãŒèª•ç”Ÿã—ãŸã€‚");
    toast("åˆæœŸåŒ–ã—ã¾ã—ãŸ");
    TypeSound.unlock();
  });

  // ----- Idle recovery -----
  setInterval(() => {
    const idleFor = session.lastKeyAt ? (now() - session.lastKeyAt) : 999999;
    const wasIdle = session.idle;
    session.idle = idleFor > 7000;
    if(session.idle && !wasIdle) pushLog("info", "ç”Ÿç‰©ã¯ä¼‘æ†©ãƒ¢ãƒ¼ãƒ‰ã«å…¥ã£ãŸã€‚");
    if(session.idle){
      state.energy = clamp(state.energy + 0.006, 0, 1);
      state.mood = clamp(state.mood - 0.004, 0, 1);
      state.glow = clamp(state.glow + 0.002, 0, 1);
      saveState();
    }
    updateHeaderUI();
  }, 1200);

  // ----- Canvas drawing -----
  let t0 = now();
  let stars = null;

  function resizeCanvasToDisplaySize(){
    const rect = cv.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const w = Math.round(rect.width * dpr);
    const h = Math.round(rect.height * dpr);
    if(cv.width !== w || cv.height !== h){
      cv.width = w; cv.height = h;
      stars = null;
    }
  }

  function initStars(W,H){
    const count = Math.floor((W*H)/18000);
    stars = [];
    const seed = (state.seed||123456) ^ hash32(state.name);
    let x = seed;
    const rnd = () => (x = (x*1664525 + 1013904223)>>>0) / 4294967296;
    for(let i=0;i<count;i++){
      stars.push({ x:rnd()*W, y:rnd()*H*0.9, r:0.6+rnd()*1.8, a:0.25+rnd()*0.55, s:0.15+rnd()*0.55 });
    }
  }

  function drawStars(W,H,t){
    if(!stars) initStars(W,H);
    ctx.save();
    for(const st of stars){
      const tw = 0.5 + 0.5*Math.sin(t*st.s + st.x*0.01);
      ctx.globalAlpha = st.a * (0.55 + tw*0.45);
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.beginPath();
      ctx.arc(st.x, st.y, st.r*(0.85+tw*0.35), 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawEye(x, y, s, blink, jitter){
    ctx.save();
    ctx.translate(x + (Math.sin((now()-t0)/1000*7 + x)*jitter), y);
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = "rgba(245,250,255,0.95)";
    ctx.beginPath();
    ctx.ellipse(0,0, s*1.05, s*0.95*blink, 0, 0, Math.PI*2);
    ctx.fill();
    const mood = state.mood;
    const px = Math.sin((now()-t0)/1000*1.4 + x)* (2 + mood*3);
    const py = Math.cos((now()-t0)/1000*1.2 + x)* (1 + mood*2);
    ctx.fillStyle = "rgba(10,16,30,0.9)";
    ctx.beginPath();
    ctx.ellipse(px, py, s*0.35, s*0.35*blink, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = `rgba(123,240,255,${0.7*state.glow+0.15})`;
    ctx.beginPath();
    ctx.ellipse(-s*0.22, -s*0.22, s*0.16, s*0.16*blink, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function drawFeelers(R, t, mood, energy){
    ctx.save();
    ctx.globalAlpha = 0.55 + state.glow*0.35;
    ctx.strokeStyle = `rgba(181,255,123,${0.25 + state.glow*0.25})`;
    ctx.lineWidth = 3;
    ctx.lineCap = "round";
    const n = 2 + Math.floor(mood*2);
    for(let i=0;i<n;i++){
      const ang = (-Math.PI/2) + (i-(n-1)/2)*0.45;
      const len = R*(0.75 + energy*0.25);
      ctx.beginPath();
      ctx.moveTo(Math.cos(ang)*R*0.55, Math.sin(ang)*R*0.55);
      const cx = Math.cos(ang)*len*0.55 + Math.sin(t*2 + i)*R*0.15;
      const cy = Math.sin(ang)*len*0.55 - Math.cos(t*2 + i)*R*0.10;
      const ex = Math.cos(ang)*len + Math.sin(t*3 + i)*R*0.12;
      const ey = Math.sin(ang)*len - Math.cos(t*2.5 + i)*R*0.12;
      ctx.quadraticCurveTo(cx,cy,ex,ey);
      ctx.stroke();
      ctx.fillStyle = `rgba(123,240,255,${0.22+state.glow*0.28})`;
      ctx.beginPath();
      ctx.arc(ex,ey, 5+state.glow*4, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawLegs(R, t, mood, energy){
    ctx.save();
    ctx.globalAlpha = 0.40 + state.glow*0.25;
    ctx.strokeStyle = `rgba(255,255,255,${0.18 + state.glow*0.20})`;
    ctx.lineWidth = 3;
    ctx.lineCap = "round";
    const legs = 4 + Math.floor(mood*6);
    for(let i=0;i<legs;i++){
      const side = (i%2===0)? -1 : 1;
      const row = Math.floor(i/2);
      const y = lerp(-R*0.05, R*0.40, row / Math.max(1,(legs/2)-1));
      const x = side * lerp(R*0.55, R*0.85, row / Math.max(1,(legs/2)-1));
      const kick = Math.sin(t* (3.5 + mood*2) + i)* (8 + energy*8);
      ctx.beginPath();
      ctx.moveTo(x*0.65, y);
      ctx.quadraticCurveTo(x*1.02 + kick*0.35*side, y+R*0.25, x*1.10 + kick*0.55*side, y+R*0.40);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawBubbles(R, t, glow){
    ctx.save();
    ctx.globalAlpha = 0.20 + glow*0.30;
    for(let i=0;i<8;i++){
      const ang = (i/8)*Math.PI*2 + t*0.25;
      const rr = R*(0.65 + Math.sin(t*0.9+i)*0.06);
      const x = Math.cos(ang)*rr*0.7;
      const y = Math.sin(ang)*rr*0.5 - R*0.15;
      ctx.fillStyle = `rgba(123,240,255,${0.10 + glow*0.22})`;
      ctx.beginPath();
      ctx.arc(x,y, 6 + Math.sin(t*2+i)*2, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawSparkles(R, t, glow){
    ctx.save();
    ctx.globalAlpha = 0.25 + glow*0.45;
    for(let i=0;i<14;i++){
      const ang = (i/14)*Math.PI*2 + t*0.35;
      const r = R*(1.05 + Math.sin(t*0.8+i)*0.08);
      const x = Math.cos(ang)*r*0.85;
      const y = Math.sin(ang)*r*0.55 - R*0.05;
      const s = 1.5 + glow*2.2 + Math.max(0, Math.sin(t*3 + i))*1.8;
      ctx.strokeStyle = `rgba(181,255,123,${0.12 + glow*0.18})`;
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.moveTo(x-s,y);
      ctx.lineTo(x+s,y);
      ctx.moveTo(x,y-s);
      ctx.lineTo(x,y+s);
      ctx.stroke();
    }
    ctx.restore();
  }

  function draw(){
    const t = (now() - t0)/1000;
    resizeCanvasToDisplaySize();
    const W = cv.width, H = cv.height;
    ctx.clearRect(0,0,W,H);

    drawStars(W,H,t);

    const floorY = H*0.76;
    const glow = state.glow;

    // floor glow
    ctx.save();
    ctx.globalAlpha = 0.35 + glow*0.35;
    const grd = ctx.createRadialGradient(W*0.5, floorY, 10, W*0.5, floorY, W*0.55);
    grd.addColorStop(0, `rgba(123,240,255,${0.32+glow*0.25})`);
    grd.addColorStop(0.5, `rgba(181,255,123,${0.10+glow*0.18})`);
    grd.addColorStop(1, `rgba(0,0,0,0)`);
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.ellipse(W*0.5, floorY, W*0.33, H*0.11, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    const stage = state.stage;
    const mood = state.mood;
    const energy = state.energy;
    const wobble = state.wobble;

    const sizeBase = lerp(58, 120, clamp((state.lv-1)/18, 0, 1));
    const sizeStage = [0.80, 0.95, 1.05, 1.12, 1.18][stage];
    const R = sizeBase * sizeStage;

    const centerX = W*0.5;
    const centerY = H*0.54;

    const awake = !session.idle;
    const bob = (Math.sin(t* (awake? 3.4: 1.2)) * (8 + wobble*10)) * (0.35 + energy*0.65);
    const sway = Math.sin(t* (awake? 2.2: 0.9)) * (10 + wobble*14) * (0.25 + energy*0.75);

    const hue1 = 185 + glow*35 + mood*18;
    const hue2 = 105 + glow*20 - mood*10;
    const alpha = 0.82;

    // shadow
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.beginPath();
    ctx.ellipse(centerX + sway*0.18, floorY+10, R*1.05, R*0.28, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.translate(centerX + sway, centerY + bob);

    const deform = (0.10 + wobble*0.18) * (awake? 1.0 : 0.6);
    const pulse = 1 + Math.sin(t* (awake? 5.0: 2.0)) * deform * (0.35 + energy*0.65);
    ctx.scale(pulse, 1/pulse);

    const bodyPath = new Path2D();
    const lobes = 6 + stage*2;
    const sp = state.spikes;
    for(let i=0;i<=360;i+=4){
      const rad = (i*Math.PI/180);
      const wave = Math.sin(rad*lobes + t*(awake? 2.2: 0.9)) * (0.06 + wobble*0.10);
      const spike = Math.max(0, Math.sin(rad*(lobes*0.5) + t*1.3)) * sp * 0.14;
      const r = R * (1 + wave + spike);
      const x = Math.cos(rad)*r;
      const y = Math.sin(rad)*r*0.92;
      if(i===0) bodyPath.moveTo(x,y); else bodyPath.lineTo(x,y);
    }
    bodyPath.closePath();

    const g = ctx.createRadialGradient(0,-R*0.35, 10, 0,0, R*1.4);
    g.addColorStop(0, `hsla(${hue1}, 90%, 70%, ${alpha})`);
    g.addColorStop(0.55, `hsla(${lerp(hue1,hue2,0.55)}, 85%, 56%, ${alpha})`);
    g.addColorStop(1, `hsla(${hue2}, 80%, 22%, ${0.95})`);
    ctx.fillStyle = g;
    ctx.fill(bodyPath);

    ctx.save();
    ctx.globalAlpha = 0.35 + glow*0.45;
    ctx.strokeStyle = `rgba(123,240,255,${0.25+glow*0.25})`;
    ctx.lineWidth = 2.2;
    ctx.stroke(bodyPath);
    ctx.restore();

    // eyes & mouth
    const eyeY = -R*0.15 + bob*0.08;
    const eyeSpread = lerp(R*0.28, R*0.42, stage/4);
    const eyeSize = lerp(7, 14, clamp((state.lv-1)/18,0,1)) * (0.85 + energy*0.4);
    const blink = (Math.sin(t* (awake? 6.0: 2.2)) > 0.92) ? 0.15 : 1.0;
    const jitter = (awake? 1: 0) * (mood*2.0);
    drawEye(-eyeSpread, eyeY, eyeSize, blink, jitter);
    drawEye(+eyeSpread, eyeY, eyeSize, blink, jitter);

    ctx.save();
    ctx.globalAlpha = 0.85;
    ctx.strokeStyle = `rgba(0,0,0,0.45)`;
    ctx.lineWidth = 3;
    ctx.lineCap = "round";
    const smile = lerp(-0.25, 0.35, state.friendliness);
    ctx.beginPath();
    ctx.arc(0, R*0.14, R*0.22, Math.PI*(0.20+smile*0.15), Math.PI*(0.80-smile*0.15), false);
    ctx.stroke();
    ctx.restore();

    if(stage >= 3) drawLegs(R, t, mood, energy);
    else if(stage >= 2) drawFeelers(R, t, mood, energy);
    else if(stage >= 1) drawBubbles(R, t, glow);

    drawSparkles(R, t, glow);

    ctx.restore();
    requestAnimationFrame(draw);
  }

  // ----- Boot -----
  function boot(){
    renderLog();
    updateHeaderUI();
    setPrompt(null);
    requestAnimationFrame(draw);
    setTimeout(() => el.typeInput.focus(), 120);
    saveState();
  }

  boot();
})();
</script>
</body>
</html>
