<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, viewport-fit=cover" />
<title>Invader Stable v7 (Mobile Single Shot / ULTRA FAST)</title>
<style>
  html,body{
    margin:0;padding:0;background:#000;overflow:hidden;
    touch-action:none;
    overscroll-behavior:none;
    -webkit-overflow-scrolling:auto;
    -webkit-text-size-adjust:100%;
  }
  canvas{position:fixed;inset:0;display:block;touch-action:none;pointer-events:auto}

  #hud{
    position:fixed;top:8px;left:8px;z-index:10;color:#fff;
    font:14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    user-select:none;pointer-events:none;
  }

  #pauseBtn{
    position:fixed;top:10px;right:10px;z-index:80;
    padding:8px 12px;font:700 14px/1 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    color:#fff;background:rgba(0,0,0,.55);
    border:2px solid rgba(255,255,255,.25);border-radius:10px;
    cursor:pointer;pointer-events:auto;user-select:none;
    touch-action:manipulation;
    -webkit-tap-highlight-color: transparent;
  }

  #msg{
    position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
    color:#fff;font:700 40px/1 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    text-shadow:0 2px 0 rgba(0,0,0,.5);
    z-index:40;pointer-events:none;text-align:center;white-space:pre-line;
  }

  /* ===== Mobile controls ===== */
  .controls{position:fixed;inset:0;z-index:70;pointer-events:none}

  #stickBase,#stickKnob{
    position:fixed;border-radius:50%;
    pointer-events:auto;
    touch-action:none !important;
    user-select:none;
    -webkit-user-select:none;
    -webkit-touch-callout:none;
    -webkit-tap-highlight-color: transparent;
    transform: translateZ(0);
  }
  #stickBase{
    width:140px;height:140px;left:22px;bottom:22px;
    background:rgba(40,40,40,.55);
    border:2px solid rgba(255,255,255,.25);
  }
  #stickKnob{
    width:74px;height:74px;left:22px;bottom:22px;
    background:rgba(0,0,0,.65);
    border:2px solid rgba(255,255,255,.20);
  }

  #shootBtn{
    position:fixed;width:120px;height:120px;
    right:22px;bottom:28px;border-radius:50%;
    pointer-events:auto;
    touch-action:none !important;
    -webkit-touch-callout:none;
    -webkit-user-select:none;
    user-select:none;
    -webkit-tap-highlight-color: rgba(0,0,0,0);
    transform: translateZ(0);
    -webkit-appearance:none;
    appearance:none;
    outline:none;

    background:radial-gradient(circle at 30% 30%,rgba(255,255,255,.35),rgba(255,0,0,.9));
    border:2px solid rgba(255,255,255,.25);
  }
  #shootLabel{
    position:fixed;right:22px;bottom:160px;
    color:#fff;font:800 14px system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    padding:6px 10px;border:2px solid rgba(255,255,255,.25);
    border-radius:10px;background:rgba(0,0,0,.45);pointer-events:none;
  }

  @media (pointer: fine) {
    .controls{display:none;}
  }
</style>
</head>
<body>
<canvas id="cv"></canvas>

<div id="hud">
  SCORE <span id="score">0</span> /
  WAVE <span id="wave">1</span><br>
  LIFE <span id="life">❤️❤️❤️</span>
</div>

<button id="pauseBtn" type="button">PAUSE</button>
<div id="msg"></div>

<div class="controls" id="controls">
  <div id="stickBase"></div>
  <div id="stickKnob"></div>
  <button id="shootBtn" type="button" aria-label="shoot"></button>
  <div id="shootLabel">SHOT</div>
</div>

<script>
(() => {
  "use strict";

  const UA = navigator.userAgent || "";
  const IS_IOS = /iP(hone|ad|od)/.test(UA);

  if (IS_IOS) {
    ["gesturestart","gesturechange","gestureend","dblclick"].forEach(t => {
      document.addEventListener(t, e => e.preventDefault(), { passive:false });
    });
  }

  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d", { alpha:false }) || cv.getContext("2d");

  const scoreEl = document.getElementById("score");
  const waveEl  = document.getElementById("wave");
  const lifeEl  = document.getElementById("life");
  const msgEl   = document.getElementById("msg");
  const pauseBtn = document.getElementById("pauseBtn");

  const controls = document.getElementById("controls");
  const stickBase = document.getElementById("stickBase");
  const stickKnob = document.getElementById("stickKnob");
  const shootBtn = document.getElementById("shootBtn");

  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const aabb = (ax,ay,aw,ah,bx,by,bw,bh) =>
    !(ax+aw<bx || ax>bx+bw || ay+ah<by || ay>by+bh);

  function resizeCanvas(){ cv.width = innerWidth; cv.height = innerHeight; }

  function calcU(){ if (innerWidth>=1200) return 7; if (innerWidth>=800) return 6; return 4; }
  function isCoarse(){
    return (window.matchMedia && window.matchMedia("(pointer: coarse)").matches)
      || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0);
  }

  const SHIP = [
    "000010000","000111000","000111000",
    "011111110","111111111","111111111","111111111"
  ];

  const ENEMY_TYPES = [
    { a:["0100010","1111111","1011101","0100010"], b:["0100010","1111111","0101010","1010101"] },
    { a:["0011100","0111110","1101011","0111110"], b:["0011100","1111111","0101010","1010101"] },
    { a:["0110110","1111111","0101010","1010101"], b:["0011100","0111110","1101011","0111110"] },
    { a:["0011100","1111111","1010101","0100010"], b:["0011100","0111110","0101010","1010101"] }
  ];

  const SHIELD = [
    "00111100","01111110","11111111","11111111","11111111","11000011"
  ];

  function drawBitmap(lines, x, y, scale, color){
    ctx.fillStyle = color;
    for(let r=0;r<lines.length;r++){
      const row = lines[r];
      for(let c=0;c<row.length;c++){
        if(row[c]==="1") ctx.fillRect(x+c*scale, y+r*scale, scale, scale);
      }
    }
  }

  const Game = {
    U: calcU(),
    isMobile: isCoarse(),

    shipW:0, shipH:0, enemyW:0, enemyH:0, shieldW:0, shieldH:0,

    score:0, wave:1, life:3,

    ready:true, clearing:false, over:false, paused:false,
    hitStop:0,
    _pendingGameOver:false,
    invincible:0, safeTimer:0,

    holdL:false, holdR:false,
    playerCanShoot:true,

    playerBottomPx:70,
    px: innerWidth/2,

    stars: [],

    cols:11, rows:5,
    fx:0, fy:0, dir:1,
    prevFx:0, prevFy:0,
    enemyInitialCount:0,
    enemyFrame:0, enemyAnimTick:0, enemyShootTick:0,
    moveAcc:0, wallPause:0,

    hpGrid: [],

    shields: [],
    shieldBoxes: [],

    // ★敵がシールドに触れている間の「少しずつ削る」用
    shieldContactTick: 0,
    shieldContactEvery: 3, // この回数に1回だけ削る（小さいほど早く削れる）

    bullets: [],
    ebullets: [],
    booms: [],

    BW:4, BH:10,

    colors: {
      shield: () => "#ff3333",
      player: () => "#44ff88",
      row: ["#ff4d4d","#ffb84d","#ffff4d","#4dff4d","#4dd2ff"]
    },

    updateLifeHud(){
      lifeEl.textContent = "❤️".repeat(Math.max(0, this.life));
    },

    playerTopY(){
      return innerHeight - this.playerBottomPx - this.shipH;
    },

    clampPlayer(){
      this.px = clamp(this.px, this.shipW/2, innerWidth - this.shipW/2);
    },

    recalcSizes(){
      this.shipW = SHIP[0].length * this.U;
      this.shipH = SHIP.length * this.U;

      const margin = 12;
      const minGapX = 0.90 * this.U;
      const availW = Math.max(120, innerWidth - margin*2);
      const maxEnemyW = (availW - (this.cols-1)*minGapX) / this.cols;
      const scale = this.isMobile ? 0.78 : 0.86;
      const targetW = maxEnemyW * scale;

      this.enemyW = clamp(targetW, 2.6*this.U, 5.5*this.U);
      this.enemyH = this.enemyW * (4/7);

      this.shieldW = 8*this.U;
      this.shieldH = 6*this.U;
    },

    resetStars(){
      this.stars = [...Array(120)].map(() => ({
        x:Math.random()*innerWidth,
        y:Math.random()*innerHeight,
        s:0.6+Math.random()*1.2
      }));
    },

    formationMetrics(){
      const minGapX = 0.90*this.U, minGapY = 1.10*this.U;
      const stepX = this.enemyW + minGapX;
      const stepY = this.enemyH + minGapY;
      const totalW = this.cols*this.enemyW + (this.cols-1)*minGapX;
      const baseY = Math.max(90, innerHeight*0.22);
      return { stepX, stepY, totalW, baseY };
    },

    countAlive(){
      let n=0;
      for(let r=0;r<this.rows;r++) for(let c=0;c<this.cols;c++) if(this.hpGrid[r][c] > 0) n++;
      return n;
    },

    rowKillScore(r){
      return (this.rows - r) * 10;
    },

    enemyProfile(){
      const fireInterval = Math.max(22, Math.floor(140 - (this.wave-1) * 8));
      const maxBullets = Math.min(12, 2 + Math.floor((this.wave-1) / 4));
      const burst = Math.min(3, 1 + Math.floor((this.wave-1) / 6));
      return { fireInterval, maxBullets, burst };
    },

    spawnEnemies(){
      this.cols = 11; this.rows = 5;
      const hp2 = (this.wave >= 4);

      this.hpGrid = Array.from({length:this.rows}, () =>
        Array.from({length:this.cols}, () => 1)
      );

      if (hp2) {
        for (let r=0;r<Math.min(2,this.rows);r++){
          for (let c=0;c<this.cols;c++) this.hpGrid[r][c] = 2;
        }
      }

      const { totalW, baseY } = this.formationMetrics();
      this.fx = (innerWidth - totalW)/2;
      this.fy = baseY;
      this.dir = 1;

      this.enemyInitialCount = this.rows*this.cols;
      this.moveAcc = 0;
      this.wallPause = 0;

      this.enemyFrame = 0;
      this.enemyAnimTick = 0;
      this.enemyShootTick = 0;
    },

    buildShieldBits(){
      const h = SHIELD.length, w = SHIELD[0].length;
      const bits = Array.from({length:h}, (_,r)=>Array.from({length:w},(_,c)=>SHIELD[r][c]==="1"));
      return {bits,w,h};
    },

    computeShieldLayout(){
      const topMin = 40;
      const gapFromPlayer = 14;
      const defaultOffset = 80;

      const playerY = this.playerTopY();
      let y = playerY - defaultOffset;

      const maxY = playerY - this.shieldH - gapFromPlayer;
      y = Math.min(y, maxY);
      y = Math.max(y, topMin);

      if(maxY < topMin){
        y = Math.max(0, maxY);
      }

      const xs = [0.2,0.4,0.6,0.8];
      return xs.map(v => ({ x: innerWidth * v - this.shieldW/2, y }));
    },

    spawnShields(){
      this.shields.length = 0;
      const proto = this.buildShieldBits();
      const layout = this.computeShieldLayout();
      for (let i=0;i<layout.length;i++){
        const {x,y} = layout[i];
        const bits = proto.bits.map(row=>row.slice());
        this.shields.push({x,y,bits,w:proto.w,h:proto.h});
      }
      this.rebuildShieldBoxes();
    },

    relayoutShields(){
      if(!this.shields.length){
        this.spawnShields();
        return;
      }
      const layout = this.computeShieldLayout();
      for(let i=0;i<this.shields.length && i<layout.length;i++){
        this.shields[i].x = layout[i].x;
        this.shields[i].y = layout[i].y;
      }
      this.rebuildShieldBoxes();
    },

    rebuildShieldBoxes(){
      this.shieldBoxes = this.shields.map(s => ({
        x:s.x, y:s.y, w:this.shieldW, h:this.shieldH,
        ref:s
      }));
    },

    shieldHitAndDamage(bx,by,bw,bh){
      if (!this.shields.length) return false;

      const cx = bx + bw/2;
      let best = null;
      let bestD = Infinity;
      for (let i=0;i<this.shieldBoxes.length;i++){
        const box = this.shieldBoxes[i];
        const mid = box.x + box.w/2;
        const d = Math.abs(cx - mid);
        if (d < bestD) { bestD = d; best = box; }
      }

      const tryDamage = (box) => {
        if(!aabb(bx,by,bw,bh, box.x,box.y, box.w,box.h)) return false;
        const s = box.ref;

        const rx = clamp(Math.floor(((bx+bw/2)-s.x)/this.U), 0, s.w-1);
        const ry = clamp(Math.floor(((by+bh/2)-s.y)/this.U), 0, s.h-1);

        const cand=[];
        for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){
          const cx=rx+dx, cy=ry+dy;
          if(cy>=0&&cy<s.h&&cx>=0&&cx<s.w&&s.bits[cy][cx]) cand.push([cy,cx]);
        }
        if(cand.length){
          const [cy,cx]=cand[(Math.random()*cand.length)|0];
          s.bits[cy][cx]=false;
        }
        return true;
      };

      if (best && tryDamage(best)) return true;

      for (let i=0;i<this.shieldBoxes.length;i++){
        const box = this.shieldBoxes[i];
        if (box === best) continue;
        if (tryDamage(box)) return true;
      }
      return false;
    },

    // ★敵がシールドに接触した時：ランダムに少しずつ削る
    damageShieldRandom(shield, hits){
      hits = Math.max(0, hits|0);
      if(!hits) return;
      // なるべく「残っているブロック」を消す
      let attempts = hits * 10;
      while(hits > 0 && attempts-- > 0){
        const r = (Math.random() * shield.h) | 0;
        const c = (Math.random() * shield.w) | 0;
        if(shield.bits[r][c]){
          shield.bits[r][c] = false;
          hits--;
        }
      }
    },

    boom(x,y){
      for(let i=0;i<10;i++){
        this.booms.push({x,y,vx:(Math.random()-.5)*5,vy:(Math.random()-.5)*5,t:18});
      }
    },

    shootOnce(){
      if(this.paused) return;
      if(this.ready || this.clearing || this.over) return;
      this.bullets.push({x:this.px - this.BW/2, y:this.playerTopY(), v:-10});
    },

    enemyShoot(){
      if(this.paused) return;
      if(this.ready || this.clearing || this.over) return;

      const prof = this.enemyProfile();
      if(this.ebullets.length >= prof.maxBullets) return;

      const alive = [];
      for(let r=0;r<this.rows;r++)for(let c=0;c<this.cols;c++){
        if(this.hpGrid[r][c] > 0) alive.push([r,c]);
      }
      if(!alive.length) return;

      const [r,c] = alive[(Math.random()*alive.length)|0];
      const {stepX,stepY} = this.formationMetrics();
      const ex = this.fx + c*stepX, ey = this.fy + r*stepY;

      const baseV = (this.isMobile ? 5 : 7);
      const add = Math.min(3, (this.wave-1) * 0.18);
      const v = baseV + add;

      const shots = Math.min(prof.burst, prof.maxBullets - this.ebullets.length);
      for(let k=0;k<shots;k++){
        const spread = (k - (shots-1)/2) * (this.BW + 2);
        this.ebullets.push({x:ex + this.enemyW/2 - this.BW/2 + spread, y:ey + this.enemyH, v});
      }
    },

    showReady(){
      clearTimeout(window._msgTimer);
      if(!this.paused) msgEl.textContent = "";
      this.ready = true;
      this.safeTimer = Math.floor(this.wave * 0.5 * 60);
      window._msgTimer = setTimeout(() => {
        if(!this.over && !this.paused) msgEl.textContent = "";
        this.ready = false;
      }, 900);
    },

    nextWave(){
      this.clearing = true;
      if(!this.paused) msgEl.textContent = "CLEAR!";
      setTimeout(() => {
        if(this.paused) return;
        msgEl.textContent = "";
        this.wave++;
        waveEl.textContent = this.wave;
        this.clearing = false;
        this.spawnEnemies();
        this.spawnShields();
        this.showReady();
      }, 900);
    },

    gameOver(){
      if(this.over) return;
      this.over = true;
      this.paused = false;
      pauseBtn.textContent = "PAUSE";
      msgEl.innerHTML = "GAME OVER<br>Tap or Enter";
      this.holdL = false;
      this.holdR = false;
    },


    // ★体当たり演出：ヒットした瞬間に「ピタ止め」してからGAME OVERを出す
    triggerRamming(contactFy){
      if(this.over) return;
      this.fy = contactFy;

      // ヒット停止（ms）
      this.hitStop = 200;

      if(this._pendingGameOver) return;
      this._pendingGameOver = true;

      setTimeout(() => {
        this.hitStop = 0;
        this._pendingGameOver = false;
        this.gameOver();
      }, 200);
    },

    msgBeforePause: "",
    setPaused(next){
      if(this.over) return;
      this.paused = !!next;
      pauseBtn.textContent = this.paused ? "RESUME" : "PAUSE";
      if(this.paused){
        this.msgBeforePause = msgEl.innerHTML;
        msgEl.textContent = "PAUSED";
        this.holdL = false; this.holdR = false;
        Input.stickReset();
        this.playerCanShoot = true;
      }else{
        if(this.msgBeforePause && this.msgBeforePause !== "PAUSED") msgEl.innerHTML = this.msgBeforePause;
        else msgEl.textContent = "";
        this.msgBeforePause = "";
      }
    },

    togglePause(){
      this.setPaused(!this.paused);
    },

    reset(){
      this.bullets.length = 0;
      this.ebullets.length = 0;
      this.booms.length = 0;

      this.shieldContactTick = 0;

      msgEl.textContent = "";
      this.score = 0;
      this.wave = 1;
      this.life = 3;

      this.invincible = 0;
      this.safeTimer = 0;

      this.over = false;
      this.clearing = false;

      this.paused = false;
      pauseBtn.textContent = "PAUSE";
      this.msgBeforePause = "";

      this.playerCanShoot = true;

      this.holdL = false; this.holdR = false;

      scoreEl.textContent = "0";
      waveEl.textContent = "1";
      this.updateLifeHud();

      this.px = innerWidth/2;
      this.clampPlayer();

      this.spawnEnemies();
      this.spawnShields();
      this.showReady();
    },

    update(dt){
      if(this.paused) return;

      // ★体当たりが見えるようにヒット停止
      if(this.hitStop > 0){
        this.hitStop -= dt;
        return;
      }

      for(const s of this.stars){
        s.y += s.s * (dt*0.06);
        if(s.y > innerHeight){
          s.y = 0;
          s.x = Math.random() * innerWidth;
        }
      }

      if(this.invincible > 0) this.invincible--;
      if(this.safeTimer > 0) this.safeTimer--;

      const sp = this.isMobile ? 3 : 4;
      if(!this.ready && !this.clearing && !this.over){
        if(this.holdL) this.px -= sp;
        if(this.holdR) this.px += sp;
      }
      this.clampPlayer();

      // ★敵の高速移動すり抜け対策：移動前の位置を保存
      this.prevFx = this.fx;
      this.prevFy = this.fy;

      const { stepX, stepY } = this.formationMetrics();
      const remaining = Math.max(1, this.countAlive());
      const initialCount = this.enemyInitialCount || remaining;
      const ratio = remaining / initialCount;

      // 生存している敵の左右端（列）を算出（生存クラスタで壁判定するため）
      let minAliveC = this.cols, maxAliveC = -1, maxAliveR = -1;
      for(let rr=0; rr<this.rows; rr++){
        for(let cc=0; cc<this.cols; cc++){
          if(this.hpGrid[rr][cc] > 0){
            if(cc < minAliveC) minAliveC = cc;
            if(cc > maxAliveC) maxAliveC = cc;
            if(rr > maxAliveR) maxAliveR = rr;
          }
        }
      }
      if(maxAliveC < 0){ minAliveC = 0; maxAliveC = this.cols - 1; maxAliveR = this.rows - 1; }

      /* =========================================================
         ★ULTRA FAST：序盤から速く、減るほどさらに加速、最後の1体は激速
         - moveInterval（ms）が小さいほど、ステップ回数が増えて速く見える
         - stepMoveX も増やして「体感速度」を上げる
      ========================================================= */
      const baseInterval = 150;  // 序盤から速い
      const minInterval  = 10;   // 終盤の限界（小さいほど爆速）

      const t = 1 - ratio;                 // 0→1（敵が減るほど大）
      const curve = Math.pow(t, 1.55);     // 小さめで「だんだん早くなる」を強める

      let moveInterval = baseInterval * (1 - curve) + minInterval * curve;

      const waveSpeedMul = 1 / (1 + (this.wave - 1) * 0.06);
      moveInterval *= waveSpeedMul;

      // 残り1体はさらに最速へ（当たりにくいレベル）
      if (remaining === 1) moveInterval = Math.min(moveInterval, 6);

      // rAF/環境差で暴走しない最低ライン
      moveInterval = Math.max(6, moveInterval);

      // 1ステップの横移動量を増やして、さらに当たりにくく
      const stepMoveX = 1.35*this.U*(1+(this.wave-1)*0.03);

      const stepDown  = 1.6*this.U;
      const wallPauseMs = 70; // 壁で止まる時間も短く

      if(!this.ready && !this.clearing && !this.over){
        this.moveAcc += dt;
        if(this.wallPause > 0){
          const use = Math.min(this.wallPause, this.moveAcc);
          this.wallPause -= use;
          this.moveAcc -= use;
        }
        while(this.moveAcc >= moveInterval){
          this.moveAcc -= moveInterval;
          const margin = 10;
          const nextFx = this.fx + this.dir * stepMoveX;

          // 生存クラスタ（生き残っている敵の左右端）で壁判定する
          const nextAliveLeft  = nextFx + minAliveC * stepX;
          const nextAliveRight = nextFx + maxAliveC * stepX + this.enemyW;

          if (nextAliveRight > innerWidth - margin) {
            const overflow = nextAliveRight - (innerWidth - margin);
            this.fx = nextFx - overflow;
            this.dir = -1;
            this.fy += stepDown;

            const playerTop = this.playerTopY();
            const lowestBottom = this.fy + maxAliveR * stepY + this.enemyH;
            if (lowestBottom >= playerTop) {
              this.fy = playerTop - (maxAliveR * stepY + this.enemyH);
              this.triggerRamming(this.fy);
              return;
            }

            this.wallPause = wallPauseMs;
            this.moveAcc = 0;
            break;

          } else if (nextAliveLeft < margin) {
            const overflow = margin - nextAliveLeft;
            this.fx = nextFx + overflow;
            this.dir = 1;
            this.fy += stepDown;

            const playerTop = this.playerTopY();
            const lowestBottom = this.fy + maxAliveR * stepY + this.enemyH;
            if (lowestBottom >= playerTop) {
              this.fy = playerTop - (maxAliveR * stepY + this.enemyH);
              this.triggerRamming(this.fy);
              return;
            }

            this.wallPause = wallPauseMs;
            this.moveAcc = 0;
            break;

          } else {
            this.fx = nextFx;
          }
        }
      }

      this.enemyAnimTick++;
      if(this.enemyAnimTick >= 28){
        this.enemyAnimTick = 0;
        this.enemyFrame = 1 - this.enemyFrame;
      }

      if(!this.ready && !this.clearing && !this.over){
        const prof = this.enemyProfile();
        this.enemyShootTick++;
        if(this.enemyShootTick >= prof.fireInterval){
          this.enemyShootTick = 0;
          this.enemyShoot();
        }
      }

      for(let i=this.bullets.length-1;i>=0;i--){
        const b=this.bullets[i];
        b.y += b.v*(dt*0.06);
        if(b.y < -20) this.bullets.splice(i,1);
      }
      for(let i=this.ebullets.length-1;i>=0;i--){
        const b=this.ebullets[i];
        b.y += b.v*(dt*0.06);
        if(b.y > innerHeight + 30) this.ebullets.splice(i,1);
      }

      for(let i=this.booms.length-1;i>=0;i--){
        const p=this.booms[i];
        p.x += p.vx;
        p.y += p.vy;
        p.t--;
        if(p.t <= 0) this.booms.splice(i,1);
      }
    },

    detectCollisions(){
      if(this.paused) return;
      if(this.hitStop > 0) return;

      // ★敵がシールドに触れている間は「少しずつ削る」（複数敵なら削れが増える）
      //   - 毎フレームだと削れ過ぎるので shieldContactEvery 回に1回だけ処理
      this.shieldContactTick++;
      if(this.shieldContactTick % this.shieldContactEvery === 0 && this.shieldBoxes.length){
        const {stepX, stepY} = this.formationMetrics();
        for(const box of this.shieldBoxes){
          let contacts = 0;

          // 生存している敵だけで接触数をカウント
          for(let r=0;r<this.rows;r++){
            for(let c=0;c<this.cols;c++){
              if(this.hpGrid[r][c] <= 0) continue;
              const ex = this.fx + c*stepX;
              const ey = this.fy + r*stepY;
              if(aabb(ex, ey, this.enemyW, this.enemyH, box.x, box.y, box.w, box.h)){
                contacts++;
                if(contacts >= 8) break;
              }
            }
            if(contacts >= 8) break;
          }

          if(contacts > 0){
            // 1体あたりの削れ量（お好みで調整：2〜6くらいが見やすい）
            const perEnemy = 3;
            const hits = Math.min(40, contacts * perEnemy);
            this.damageShieldRandom(box.ref, hits);
          }
        }
      }

      // ★敵の体当たり（高速でも通り抜けない：スイープAABB）
      if(!this.over && !this.ready && !this.clearing){
        const shipX = this.px - this.shipW/2;
        const shipY = this.playerTopY();
        const shipW = this.shipW;
        const shipH = this.shipH;

        const { stepX, stepY } = this.formationMetrics();
        const fx0 = (typeof this.prevFx === "number") ? this.prevFx : this.fx;
        const fy0 = (typeof this.prevFy === "number") ? this.prevFy : this.fy;

        let maxAliveR = -1;
        for(let rr=0; rr<this.rows; rr++){
          for(let cc=0; cc<this.cols; cc++){
            if(this.hpGrid[rr][cc] > 0) maxAliveR = Math.max(maxAliveR, rr);
          }
        }

        for(let r=0; r<this.rows; r++){
          for(let c=0; c<this.cols; c++){
            if(this.hpGrid[r][c] <= 0) continue;

            const exA = fx0 + c*stepX;
            const eyA = fy0 + r*stepY;
            const exB = this.fx + c*stepX;
            const eyB = this.fy + r*stepY;

            const sx = Math.min(exA, exB);
            const sy = Math.min(eyA, eyB);
            const sw = Math.max(exA + this.enemyW, exB + this.enemyW) - sx;
            const sh = Math.max(eyA + this.enemyH, eyB + this.enemyH) - sy;

            if(aabb(sx, sy, sw, sh, shipX, shipY, shipW, shipH)){
              if(maxAliveR >= 0){
                const enemyBottom = this.fy + maxAliveR*stepY + this.enemyH;
                const over = enemyBottom - shipY;
                if(over > 0) this.fy -= over;
              }

              const HIT_MS = 260;
              this.hitStop = Math.max(this.hitStop, HIT_MS);

              if(!this._pendingGameOver){
                this._pendingGameOver = true;
                setTimeout(() => {
                  this.hitStop = 0;
                  this._pendingGameOver = false;
                  this.gameOver();
                }, HIT_MS);
              }
              return;
            }
          }
        }
      }

      for(let i=this.bullets.length-1;i>=0;i--){
        const b=this.bullets[i];
        if(this.shieldHitAndDamage(b.x,b.y,this.BW,this.BH)) this.bullets.splice(i,1);
      }
      for(let i=this.ebullets.length-1;i>=0;i--){
        const b=this.ebullets[i];
        if(this.shieldHitAndDamage(b.x,b.y,this.BW,this.BH)) this.ebullets.splice(i,1);
      }

      // ★敵が自機に体当たりしたら即ゲームオーバー
      if(!this.over){
        const pl = this.px - this.shipW/2;
        const pt = this.playerTopY();
        const pw = this.shipW;
        const ph = this.shipH;
        const {stepX, stepY} = this.formationMetrics();
        for(let r=0;r<this.rows;r++){
          for(let c=0;c<this.cols;c++){
            if(this.hpGrid[r][c] <= 0) continue;
            const ex = this.fx + c*stepX;
            const ey = this.fy + r*stepY;
            if(aabb(ex,ey,this.enemyW,this.enemyH, pl,pt,pw,ph)){
              this.fy = pt - (r * stepY + this.enemyH);
              this.triggerRamming(this.fy);
              return;
            }
          }
        }
      }

      const {stepX,stepY} = this.formationMetrics();
      for(let i=this.bullets.length-1;i>=0;i--){
        const b=this.bullets[i];
        const c=Math.floor((b.x - this.fx)/stepX);
        const r=Math.floor((b.y - this.fy)/stepY);
        if(r>=0 && r<this.rows && c>=0 && c<this.cols && this.hpGrid[r][c] > 0){
          const ex=this.fx + c*stepX;
          const ey=this.fy + r*stepY;
          if(aabb(b.x,b.y,this.BW,this.BH, ex,ey, this.enemyW,this.enemyH)){
            this.bullets.splice(i,1);

            this.hpGrid[r][c]--;
            this.boom(ex+this.enemyW/2, ey+this.enemyH/2);

            if(this.hpGrid[r][c] <= 0){
              this.score += this.rowKillScore(r);
              scoreEl.textContent = this.score;
              if(this.countAlive()===0 && !this.over && !this.clearing) this.nextWave();
            }
          }
        }
      }

      if(!this.over){
        const pl = this.px - this.shipW/2;
        const pt = this.playerTopY();
        for(let i=this.ebullets.length-1;i>=0;i--){
          const b=this.ebullets[i];
          if(aabb(b.x,b.y,this.BW,this.BH, pl,pt, this.shipW,this.shipH)){
            this.ebullets.splice(i,1);
            if(this.invincible===0 && this.safeTimer===0){
              this.life--;
              this.updateLifeHud();
              this.boom(this.px, pt+this.shipH/2);
              this.invincible = 60;
              if(this.life<=0) this.gameOver();
            }
          }
        }
      }
    },

    render(){
      ctx.fillStyle="#000";
      ctx.fillRect(0,0,innerWidth,innerHeight);

      ctx.fillStyle="#fff";
      for(const s of this.stars) ctx.fillRect(s.x,s.y,2,2);

      const sc = this.colors.shield();
      for(const s of this.shields){
        ctx.fillStyle = sc;
        for(let r=0;r<s.h;r++){
          for(let c=0;c<s.w;c++){
            if(s.bits[r][c]) ctx.fillRect(s.x + c*this.U, s.y + r*this.U, this.U, this.U);
          }
        }
      }

      const {stepX,stepY} = this.formationMetrics();
      for(let r=0;r<this.rows;r++){
        for(let c=0;c<this.cols;c++){
          if(this.hpGrid[r][c] <= 0) continue;
          const type = ENEMY_TYPES[r % ENEMY_TYPES.length];
          const bmp = this.enemyFrame ? type.b : type.a;
          const color = this.colors.row[r % this.colors.row.length];
          const x = this.fx + c*stepX;
          const y = this.fy + r*stepY;
          const scale = Math.max(1, Math.round(this.enemyW/7));
          drawBitmap(bmp, x, y, scale, color);

          if(this.hpGrid[r][c] >= 2){
            ctx.fillStyle="rgba(255,255,255,.65)";
            ctx.fillRect(x, y-3, Math.max(10, this.enemyW*0.30), 2);
          }
        }
      }

      drawBitmap(SHIP, this.px - this.shipW/2, this.playerTopY(), this.U, this.colors.player());

      ctx.fillStyle="cyan";
      for(const b of this.bullets) ctx.fillRect(b.x,b.y,this.BW,this.BH);

      ctx.fillStyle="orange";
      for(const b of this.ebullets) ctx.fillRect(b.x,b.y,this.BW,this.BH);

      ctx.fillStyle="orange";
      for(const p of this.booms) ctx.fillRect(p.x,p.y,4,4);

      if(this.paused){
        ctx.fillStyle="rgba(0,0,0,.25)";
        ctx.fillRect(0,0,innerWidth,innerHeight);
      }
    }
  };

  const Input = {
    stick: { baseCx:0, baseCy:0, radius:52, dx:0 },
    stickTouchActive:false,

    updateStickGeometry(){
      const r = stickBase.getBoundingClientRect();
      this.stick.baseCx = r.left + r.width/2;
      this.stick.baseCy = r.top  + r.height/2;
    },

    setKnobPos(x,y){
      const w = stickKnob.offsetWidth || 74;
      const h = stickKnob.offsetHeight || 74;
      stickKnob.style.left = (x - w/2) + "px";
      stickKnob.style.top  = (y - h/2) + "px";
    },

    applyStick(){
      const dead = 0.18;
      if(Math.abs(this.stick.dx) < dead){
        Game.holdL = false; Game.holdR = false;
        return;
      }
      if(this.stick.dx < 0){
        Game.holdL = true; Game.holdR = false;
      }else{
        Game.holdR = true; Game.holdL = false;
      }
    },

    stickReset(){
      this.stickTouchActive = false;
      this.stick.dx = 0;
      Game.holdL = false;
      Game.holdR = false;
      this.updateStickGeometry();
      this.setKnobPos(this.stick.baseCx, this.stick.baseCy);
    },

    stickMoveTouch(t){
      const vx = t.clientX - this.stick.baseCx;
      const max = this.stick.radius;
      const cl = Math.min(Math.abs(vx), max);
      const dx = vx < 0 ? -cl : cl;

      this.setKnobPos(this.stick.baseCx + dx, this.stick.baseCy);
      this.stick.dx = clamp(vx / max, -1, 1);
      this.applyStick();
    },

    updateControlsVisibility(){
      controls.style.display = Game.isMobile ? "block" : "none";
      this.updateStickGeometry();
      this.setKnobPos(this.stick.baseCx, this.stick.baseCy);
    }
  };

  pauseBtn.addEventListener("click", (e)=>{
    e.preventDefault();
    Game.togglePause();
  }, {passive:false});

  addEventListener("keydown",(e)=>{
    if(e.key==="p"||e.key==="P"||e.key==="Escape"){
      Game.togglePause();
      return;
    }
    if(Game.paused) return;

    if(Game.over && e.key==="Enter"){
      Game.reset();
      return;
    }

    if(e.code==="ArrowLeft") Game.holdL=true;
    if(e.code==="ArrowRight") Game.holdR=true;

    if(e.code==="KeyA" && Game.playerCanShoot){
      Game.playerCanShoot = false;
      Game.shootOnce();
    }
  });

  addEventListener("keyup",(e)=>{
    if(Game.paused) return;
    if(e.code==="ArrowLeft") Game.holdL=false;
    if(e.code==="ArrowRight") Game.holdR=false;
    if(e.code==="KeyA") Game.playerCanShoot = true;
  });

  ["touchstart","touchmove","touchend"].forEach(t=>{
    document.addEventListener(t, e=>{
      if(e.target && e.target.id === "shootBtn") e.preventDefault();
    }, {passive:false});
  });

  const onStickStart = (e) => {
    if(!Game.isMobile || Game.paused || Game.over) return;
    Input.stickTouchActive = true;
    Input.updateStickGeometry();
    if(e.touches && e.touches[0]) Input.stickMoveTouch(e.touches[0]);
    e.preventDefault();
    e.stopPropagation();
  };

  stickBase.addEventListener("touchstart", onStickStart, {passive:false});
  stickKnob.addEventListener("touchstart", onStickStart, {passive:false});

  window.addEventListener("touchmove",(e)=>{
    if(!Input.stickTouchActive || Game.paused) return;
    if(e.touches && e.touches[0]) Input.stickMoveTouch(e.touches[0]);
    e.preventDefault();
    e.stopPropagation();
  }, {passive:false});

  const endStickTouch = (e) => {
    if(!Input.stickTouchActive) return;
    Input.stickReset();
    e.preventDefault();
    e.stopPropagation();
  };
  window.addEventListener("touchend", endStickTouch, {passive:false});
  window.addEventListener("touchcancel", endStickTouch, {passive:false});

  const shootOnceOnTouch = (e) => {
    if(!Game.isMobile || Game.paused) return;
    if(Game.over){ Game.reset(); return; }

    shootBtn.blur();
    if(document.activeElement) document.activeElement.blur();

    Game.shootOnce();

    e.preventDefault();
    e.stopPropagation();
  };

  shootBtn.addEventListener("touchstart", shootOnceOnTouch, {passive:false});
  shootBtn.addEventListener("touchend", (e)=>{ e.preventDefault(); e.stopPropagation(); }, {passive:false});
  shootBtn.addEventListener("touchcancel", (e)=>{ e.preventDefault(); e.stopPropagation(); }, {passive:false});

  let resizeQueued=false;
  addEventListener("resize",()=>{
    if(resizeQueued) return;
    resizeQueued=true;
    requestAnimationFrame(()=>{
      resizeQueued=false;

      resizeCanvas();

      const oldIsMobile = Game.isMobile;
      Game.U = calcU();
      Game.isMobile = isCoarse();
      const bpChanged = (oldIsMobile !== Game.isMobile);

      Game.recalcSizes();
      Game.resetStars();
      Game.clampPlayer();
      Input.updateControlsVisibility();

      if(bpChanged){
        Game.reset();
        return;
      }

      Game.relayoutShields();

      const {totalW, baseY} = Game.formationMetrics();
      Game.fx = (innerWidth - totalW)/2;
      Game.fy = baseY;

      if(Game.paused) Input.stickReset();
    });
  });

  function loop(){
    const now = performance.now();
    const dt = Math.min(34, now - (loop._last || now));
    loop._last = now;

    Game.update(dt);
    Game.detectCollisions();
    Game.render();

    requestAnimationFrame(loop);
  }

  resizeCanvas();
  Game.recalcSizes();
  Game.resetStars();
  Input.updateControlsVisibility();
  Input.stickReset();
  Game.updateLifeHud();
  Game.reset();
  loop();

})();
</script>
</body>
</html>
